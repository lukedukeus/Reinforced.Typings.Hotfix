<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reinforced.Typings</name>
    </assembly>
    <members>
        <member name="T:Reinforced.Typings.AccessModifier">
            <summary>
                Represents member's access modifier
            </summary>
        </member>
        <member name="F:Reinforced.Typings.AccessModifier.Private">
            <summary>
                private
            </summary>
        </member>
        <member name="F:Reinforced.Typings.AccessModifier.Protected">
            <summary>
                protected
            </summary>
        </member>
        <member name="F:Reinforced.Typings.AccessModifier.Public">
            <summary>
                public
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.Dependency.RtImport">
            <summary>
            Import declaration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.Target">
            <summary>
            Targets list
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.IsWildcard">
            <summary>
            Gets flag whether RtImport is wildcard import
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.WildcardAlias">
            <summary>
            Gets wildcard alias of import
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.From">
            <summary>
            Import source
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.IsRequire">
            <summary>
            When true, "from" part will be replaced with "= require('From')"
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtImport.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtImport.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtImport.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtImport.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.Dependency.RtReference">
            <summary>
            AST node for TS reference exposed as comment
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtReference.Path">
            <summary>
            File to reference
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.Dependency.RtReference.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtReference.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtReference.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.Dependency.RtReference.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.DocTag">
            <summary>
            Describes all possible JSDOC tags
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Abstract">
            <summary> This member must be implemented (or overridden) by the inheritor. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Access">
            <summary> Specify the access level of this member (private, public, or protected). </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Alias">
            <summary> Treat a member as if it had a different name. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Augments">
            <summary> Indicate that a symbol inherits from, ands adds to, a parent symbol. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Author">
            <summary> Identify the author of an item. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Borrows">
            <summary> This object uses something from another object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Callback">
            <summary> Document a callback function. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Class">
            <summary> This function is intended to be called with the "new" keyword. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Classdesc">
            <summary> Use the following text to describe the entire class. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Constant">
            <summary> Document an object as a constant. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Constructs">
            <summary> This function member will be the constructor for the previous class. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Copyright">
            <summary> Document some copyright information. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Default">
            <summary> Document the default value. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Deprecated">
            <summary> Document that this is no longer the preferred way. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Description">
            <summary> Describe a symbol. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Enum">
            <summary> Document a collection of related properties. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Event">
            <summary> Document an event. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Example">
            <summary> Provide an example of how to use a documented item. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Exports">
            <summary> Identify the member that is exported by a JavaScript module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.External">
            <summary> Identifies an external class, namespace, or module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.File">
            <summary> Describe a file. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Fires">
            <summary> Describe the events this method may fire. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Function">
            <summary> Describe a function or method. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Global">
            <summary> Document a global object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Ignore">
            <summary> Omit a symbol from the documentation. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Implements">
            <summary> This symbol implements an interface. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Inheritdoc">
            <summary> Indicate that a symbol should inherit its parent's documentation. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Inner">
            <summary> Document an inner object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Instance">
            <summary> Document an instance member. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Interface">
            <summary> This symbol is an interface that others can implement. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Kind">
            <summary> What kind of symbol is this? </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Lends">
            <summary> Document properties on an object literal as if they belonged to a symbol with a given name. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.License">
            <summary> Identify the license that applies to this code. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Listens">
            <summary> List the events that a symbol listens for. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Member">
            <summary> Document a member. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Memberof">
            <summary> This symbol belongs to a parent symbol. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Mixes">
            <summary> This object mixes in all the members from another object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Mixin">
            <summary> Document a mixin object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Module">
            <summary> Document a JavaScript module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Name">
            <summary> Document the name of an object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Namespace">
            <summary> Document a namespace object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Override">
            <summary> Indicate that a symbol overrides its parent. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Param">
            <summary> Document the parameter to a function. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Private">
            <summary> This symbol is meant to be private. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Property">
            <summary> Document a property of an object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Protected">
            <summary> This symbol is meant to be protected. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Public">
            <summary> This symbol is meant to be public. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Readonly">
            <summary> This symbol is meant to be read-only. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Requires">
            <summary> This file requires a JavaScript module. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Returns">
            <summary> Document the return value of a function. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.See">
            <summary> Refer to some other documentation for more information. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Since">
            <summary> When was this feature added? </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Static">
            <summary> Document a static member. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Summary">
            <summary> A shorter version of the full description. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.This">
            <summary> What does the 'this' keyword refer to here? </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Throws">
            <summary> Describe what errors could be thrown. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Todo">
            <summary> Document tasks to be completed. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Tutorial">
            <summary> Insert a link to an included tutorial file. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Type">
            <summary> Document the type of an object. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Typedef">
            <summary> Document a custom type. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Variation">
            <summary> Distinguish different objects with the same name. </summary> 
        </member>
        <member name="F:Reinforced.Typings.Ast.DocTag.Version">
            <summary>
            Documents the version number of an item
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.DocTagExtensions">
            <summary>
            Extension methods for DocTag enum
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.DocTagExtensions.Tagname(Reinforced.Typings.Ast.DocTag)">
            <summary>
            Converts DocTag value to corresponding JSDOC-friendly name
            </summary>
            <param name="tag">Tag instance</param>
            <returns>JSDOC-friendly name</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.IDecoratable">
            <summary>
            Node containing decorators
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.IDecoratable.Decorators">
            <summary>
            Set of decorators applied to node
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.IRtVisitor`1">
            <summary>
            Base interface for visitor traversing simple TypeScript AST tree
            </summary>
            <typeparam name="T">Node traverse result</typeparam>
        </member>
        <member name="T:Reinforced.Typings.Ast.IRtVisitor">
            <summary>
            Base interface for void visitor traversing simple TypeScript AST tree
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.ITypeMember">
            <summary>
            Abstraction for RtClass and RtInterface AST
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Export">
            <summary>
            Denotes current class to be exported
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.DefaultExport">
            <summary>
            Denotes that current class must be default export of module
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Members">
            <summary>
            Class/interface members
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Name">
            <summary>
            class/interface name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Implementees">
            <summary>
            Implementing types names
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.ITypeMember.Order">
            <summary>
            Order of writing
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.JsdocTagAttribute">
            <summary>
            JSDOC tag attribute to convert enum name back to JSDOC tag
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.JsdocTagAttribute.RawTagName">
            <summary>
            Raw tag name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.JsdocTagAttribute.#ctor(System.String)">
            <summary>
            Constructs new instance of JsdicTag attribute
            </summary>
            <param name="rawTagName">Raw tag name</param>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtArgument">
            <summary>
            AST node for method parameter
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.#ctor">
            <summary>
            Constructs new RtArgument
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Identifier">
            <summary>
            Parameter identifier
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.DefaultValue">
            <summary>
            Default value (raw typescript expression)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.IsVariableParameters">
            <summary>
            Is this parameter represents variable method parameterss
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Type">
            <summary>
            Argument type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtArgument.ToString">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtArgument.Decorators">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtClass">
            <summary>
            AST node for TypeScript class
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Decorators">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Documentation">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Name">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Implementees">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Extendee">
            <summary>
            Gets or sets type name that this class is being extened (inherit) from
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Members">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Abstract">
            <summary>
            Gets or sets whether generated class will be abstract or not
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtClass.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtClass.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtClass.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtClass.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtCompilationUnit">
            <summary>
            Abstract AST node for class/interface/enum
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtCompilationUnit.Export">
            <summary>
            Denotes current class to be exported
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtCompilationUnit.DefaultExport">
            <summary>
            Denotes that current class must be default export of module
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtCompilationUnit.Order">
            <summary>
            Order of writing
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtConstructor">
            <summary>
            AST node for class constructor
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.Arguments">
            <summary>
            Constructor parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.SuperCallParameters">
            <summary>
            Array of arguments to be substitute to super(...) call
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.NeedsSuperCall">
            <summary>
            When true, super(...) call will be generated. Otherwise will not
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtConstructor.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.Body">
            <summary>
            Implementation body (raw content)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtConstructor.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtConstructor.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtConstructor.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtDecorator">
            <summary>
            Syntax node for TS decorator
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtDecorator.Decorator">
            <summary>
            Decorator name (everything that must follow after "@")
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtDecorator.Order">
            <summary>
            Order of appearence
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtDecorator.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtDecorator.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtDecorator.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtDecorator.#ctor(System.String,System.Double)">
            <summary>
            Constructs new RtDecorator
            </summary>
            <param name="decorator">Decorator content</param>
            <param name="order">Decorator order</param>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtEnum">
            <summary>
            AST node for TypeScript enumeration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.EnumName">
            <summary>
            Enum name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Values">
            <summary>
            Enum values
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnum.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.IsConst">
            <summary>
            When true, results "const" enum instead of usual
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnum.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnum.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnum.Decorators">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtEnumValue">
            <summary>
            AST node for TypeScript enumeration value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.EnumValueName">
            <summary>
            Value name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.EnumValue">
            <summary>
            Value value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.LineAfter">
            <summary>
            Gets or sets line that will follow after member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtEnumValue.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnumValue.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtEnumValue.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtField">
            <summary>
            AST node for TypeScript field
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Identifier">
            <summary>
            Field name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Type">
            <summary>
            Field type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.InitializationExpression">
            <summary>
            TypeScript expression to initialize field
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtField.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtField.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtField.#ctor">
            <summary>
            Constructs new RtField
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtField.Decorators">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtFunction">
            <summary>
            AST node for TypeScript member function
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtFunction.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.IsAsync">
            <summary>
            Gets or sets whether function is async
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.Identifier">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.ReturnType">
            <summary>
            Function return type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.Arguments">
            <summary>
            Function parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.Decorators">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.Body">
            <summary>
            Function body (supplied as raw text)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtFunction.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtFunction.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtFunction.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtIdentifier">
            <summary>
            AST node for identifier name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.#ctor(System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="identifierName">identifier name</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtIdentifier.IdentifierName">
            <summary>
            Identifier name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtIdentifier.IsNullable">
            <summary>
            Is current identifier nullable
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtIdentifier.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtIdentifier.ToString">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.RtInterface">
            <summary>
            AST node for typeScript interface
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Name">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Implementees">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Documentation">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Members">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Ast.RtInterface.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtInterface.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtInterface.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtInterface.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtJsdocNode">
            <summary>
            AST node for JSDOC documentation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtJsdocNode.Description">
            <summary>
            Main documentation text
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtJsdocNode.TagToDescription">
            <summary>
            Additional JSDOC documentation tags
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtJsdocNode.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtJsdocNode.AddTag(Reinforced.Typings.Ast.DocTag,System.String)">
            <summary>
            Adds an additional JSDOC documentation tag.
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtMember">
            <summary>
            Abstract AST node for class/interface member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.Documentation">
            <summary>
            JSDOC
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.AccessModifier">
            <summary>
            Access modifier
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.IsStatic">
            <summary>
            Is member static
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.LineAfter">
            <summary>
            Gets or sets line that will follow after member
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtMember.Order">
            <summary>
            Member order
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtNamespace">
            <summary>
            AST node for TypeScript module
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNamespace.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.IsAmbientNamespace">
            <summary>
            Identifies nameless namespace that only wraps CompilationUnits without module name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.Name">
            <summary>
            Module name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.Export">
            <summary>
            Denotes whether namespace must be exported or not
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.GenerationMode">
            <summary>
            Denotes namespace generation mode
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.CompilationUnits">
            <summary>
            Members of module - compilation units. Classes/enums/interfaces
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNamespace.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNamespace.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNamespace.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.NamespaceGenerationMode">
            <summary>
            Switches mode for generating namespace.
            If UseModules set to true then namespace must be 
            exported as Namespaces.
            If modules are not used then namespaces must represent modules
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Ast.NamespaceGenerationMode.Module">
            <summary>
            Export namespace as module
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Ast.NamespaceGenerationMode.Namespace">
            <summary>
            Export namespace as namespace
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtNode">
            <summary>
            Base Reinforced.Typings AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtNode.Children">
            <summary>
            Child nodes
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNode.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <summary>
            Visitor acceptance
            </summary>
            <param name="visitor">Visitor</param>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtNode.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <summary>
            Typed visitor acceptance
            </summary>
            <param name="visitor">Visitor</param>
        </member>
        <member name="T:Reinforced.Typings.Ast.RtRaw">
            <summary>
            AST node exposing raw text to be output to resulting file
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.#ctor(System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="rawContent">Raw text to be output to resulting file</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtRaw.RawContent">
            <summary>
            Raw text to be output to resulting file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtRaw.Order">
            <summary>
            Order of RtRaw appearance
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.RtRaw.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.RtRaw.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtArrayType">
            <summary>
            AST node for array type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtArrayType.ElementType">
            <summary>
            Array element type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs array type from existing type
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtArrayType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.ToString">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.GetHashCode">
            <summary>Serves as the default hash function.</summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.op_Equality(Reinforced.Typings.Ast.TypeNames.RtArrayType,Reinforced.Typings.Ast.TypeNames.RtArrayType)">
            <summary>Returns a value that indicates whether the values of two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtArrayType" /> objects are equal.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtArrayType.op_Inequality(Reinforced.Typings.Ast.TypeNames.RtArrayType,Reinforced.Typings.Ast.TypeNames.RtArrayType)">
            <summary>Returns a value that indicates whether two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtArrayType" /> objects have different values.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtAsyncType">
            <summary>
            AST node for async return types of type "Promise".
            </summary>
            <remarks>With TypeScript, "Promise" use "generics" to define the resulting type of the "Promise". This is
            defined by a nested <see cref="P:Reinforced.Typings.Ast.TypeNames.RtAsyncType.TypeNameOfAsync"/></remarks>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtAsyncType.TypeNameOfAsync">
            <summary>
            Type name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtAsyncType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.ToString">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.GetHashCode">
            <summary>Serves as the default hash function.</summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.op_Equality(Reinforced.Typings.Ast.TypeNames.RtAsyncType,Reinforced.Typings.Ast.TypeNames.RtAsyncType)">
            <summary>Returns a value that indicates whether the values of two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtAsyncType" /> objects are equal.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtAsyncType.op_Inequality(Reinforced.Typings.Ast.TypeNames.RtAsyncType,Reinforced.Typings.Ast.TypeNames.RtAsyncType)">
            <summary>Returns a value that indicates whether two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtAsyncType" /> objects have different values.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtDelegateType">
            <summary>
            AST node for delegate type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Arguments">
            <summary>
            Consumed arguments
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Result">
            <summary>
            Returning result
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.#ctor(Reinforced.Typings.Ast.RtArgument[],Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="arguments">Delegate parameters</param>
            <param name="result">Delegate result type</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.ToString">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.GetHashCode">
            <summary>Serves as the default hash function.</summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.op_Equality(Reinforced.Typings.Ast.TypeNames.RtDelegateType,Reinforced.Typings.Ast.TypeNames.RtDelegateType)">
            <summary>Returns a value that indicates whether the values of two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtDelegateType" /> objects are equal.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDelegateType.op_Inequality(Reinforced.Typings.Ast.TypeNames.RtDelegateType,Reinforced.Typings.Ast.TypeNames.RtDelegateType)">
            <summary>Returns a value that indicates whether two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtDelegateType" /> objects have different values.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtDictionaryType">
            <summary>
            AST node for Dictionary type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName,Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="keySimpleType">Type for dictionary key</param>
            <param name="valueSimpleType">Type for disctionary value</param>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName,Reinforced.Typings.Ast.TypeNames.RtTypeName,System.Boolean)">
            <summary>
            Constructs new instance of AST node
            </summary>
            <param name="keySimpleType">Type for dictionary key</param>
            <param name="valueSimpleType">Type for disctionary value</param>
            <param name="isKeyEnum">A flag specifying whether the key is an enum type.</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.KeyType">
            <summary>
            Type for dictionary key
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.ValueType">
            <summary>
            Type for disctionary value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.IsKeyEnum">
            <summary>
            A flag indicating whether the key is an enum type, and a mapped type should be generated.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.ToString">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.GetHashCode">
            <summary>Serves as the default hash function.</summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.op_Equality(Reinforced.Typings.Ast.TypeNames.RtDictionaryType,Reinforced.Typings.Ast.TypeNames.RtDictionaryType)">
            <summary>Returns a value that indicates whether the values of two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtDictionaryType" /> objects are equal.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtDictionaryType.op_Inequality(Reinforced.Typings.Ast.TypeNames.RtDictionaryType,Reinforced.Typings.Ast.TypeNames.RtDictionaryType)">
            <summary>Returns a value that indicates whether two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtDictionaryType" /> objects have different values.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName">
            <summary>
            AST node for simple type name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName[],System.String,System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor(System.String)">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor(System.String,Reinforced.Typings.Ast.TypeNames.RtTypeName[])">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.GenericArguments">
            <summary>
            Type name generic arguments
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Prefix">
            <summary>
            Type namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.HasPrefix">
            <summary>
            <c>true</c> if the <see cref="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Prefix"/> is not empty.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.TypeName">
            <summary>
            Type name
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.#ctor">
            <summary>
            Constructs new instance of AST node
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.ToString">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.GetHashCode">
            <summary>Serves as the default hash function.</summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.op_Equality(Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName,Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName)">
            <summary>Returns a value that indicates whether the values of two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName" /> objects are equal.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName.op_Inequality(Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName,Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName)">
            <summary>Returns a value that indicates whether two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtSimpleTypeName" /> objects have different values.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtTuple">
            <summary>
            AST node for TypeScript tuple type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.#ctor">
            <summary>
            Constructs new RtTuple
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.#ctor(System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Constructs new RtTuple with specified type paranmeters
            </summary>
            <param name="tupleTypes">Types for tuple</param>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.#ctor(Reinforced.Typings.Ast.TypeNames.RtTypeName[])">
            <summary>
            Constructs new RtTuple with specified type paranmeters
            </summary>
            <param name="tupleTypes">Types for tuple</param>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtTuple.TupleTypes">
            <summary>
            All types that must participate tuple
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Ast.TypeNames.RtTuple.Children">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.Accept(Reinforced.Typings.Ast.IRtVisitor)">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.Accept``1(Reinforced.Typings.Ast.IRtVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.ToString">
            <inheritdoc />
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>
            <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.GetHashCode">
            <summary>Serves as the default hash function.</summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.op_Equality(Reinforced.Typings.Ast.TypeNames.RtTuple,Reinforced.Typings.Ast.TypeNames.RtTuple)">
            <summary>Returns a value that indicates whether the values of two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtTuple" /> objects are equal.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, false.</returns>
        </member>
        <member name="M:Reinforced.Typings.Ast.TypeNames.RtTuple.op_Inequality(Reinforced.Typings.Ast.TypeNames.RtTuple,Reinforced.Typings.Ast.TypeNames.RtTuple)">
            <summary>Returns a value that indicates whether two <see cref="T:Reinforced.Typings.Ast.TypeNames.RtTuple" /> objects have different values.</summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="T:Reinforced.Typings.Ast.TypeNames.RtTypeName">
            <summary>
            Abstract AST node for type name
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute">
            <summary>
                Interface containing base properties for some attributes
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportMethods">
            <summary>
                When true, code for all methods will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportProperties">
            <summary>
                When true, code for all properties will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportFields">
            <summary>
                When true, code for all fields will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.DefaultMethodCodeGenerator">
            <summary>
                Reference to code geenrator which will be applied to every method
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.IAutoexportSwitchAttribute.AutoExportConstructors">
            <summary>
                When true, code for all constructors will be automatically generated
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsAddTypeImportAttribute">
            <summary>
                This attribute is used to add import directive to file containing single TS class typing.
                It is only used while splitting generated type sto different files
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.ImportTarget">
            <summary>
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.ImportSource">
            <summary>
            Import source is everything that follows after "from" keyword. 
            Please note that you do not have to specify quotes here! Quotes will be added automatically
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.ImportRequire">
            <summary>
            When true, import will be generated as "import ImportTarget = require('ImportSource')"
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsAddTypeImportAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Cosntructs new Rtimport
            </summary>
            <param name="importTarget">Target</param>
            <param name="importSource">Source</param>
            <param name="importRequire">Is import "=require(...)"</param>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute">
            <summary>
                This attribute is used to add reference directive to file containing single TS class typing.
                It is only used while splitting generated type sto different files
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.#ctor(System.Type)">
            <summary>
                Constructs new instance of TsAddTypeReferenceAttribute using referenced type
            </summary>
            <param name="type">Type reference</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsAddTypeReferenceAttribute using referenced type
            </summary>
            <param name="rawPath">Raw reference</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.Type">
            <summary>
                Type that should be referenced
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAddTypeReferenceAttribute.RawPath">
            <summary>
                Raw reference path that will be added to target file
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsAttributeBase">
            <summary>
                Base for all attributes
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsAttributeBase.CodeGeneratorType">
            <summary>
                Dummy function body generator
                If empty then it's being generated empty/return null body.
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsBaseParamAttribute">
            <summary>
                Denotes parameter name and constant value for constructor's :base call
                We need this attribute because it is programmatically impossible to determine :base call parameters
                via reflection. So in this case we need some help from user's side
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="value">TypeScript expression to be supplied for super() call</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
            <param name="sixthValue">TypeScript expression to be supplied for super() call at position 6</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
            <param name="sixthValue">TypeScript expression to be supplied for super() call at position 6</param>
            <param name="seventhValue">TypeScript expression to be supplied for super() call at position 7</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsBaseParamAttribute.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
                Creates instance of TsBaseParamAttribute
            </summary>
            <param name="firstValue">TypeScript expression to be supplied for super() call at position 1</param>
            <param name="secondValue">TypeScript expression to be supplied for super() call at position 2</param>
            <param name="thirdValue">TypeScript expression to be supplied for super() call at position 3</param>
            <param name="fourthValue">TypeScript expression to be supplied for super() call at position 4</param>
            <param name="fifthValue">TypeScript expression to be supplied for super() call at position 5</param>
            <param name="sixthValue">TypeScript expression to be supplied for super() call at position 6</param>
            <param name="seventhValue">TypeScript expression to be supplied for super() call at position 7</param>
            <param name="eighthValue">TypeScript expression to be supplied for super() call at position 8</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsBaseParamAttribute.Values">
            <summary>
                Parameters for super() call
                Here should be stored TypeScript expressions
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsClassAttribute">
            <summary>
                This attribute will export member as typescript class definition
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsClassAttribute.#ctor">
            <summary>
                Constructs new instance of TsClassAttribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportMethods">
            <summary>
                Export all methods automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportProperties">
            <summary>
                Export all properties automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportFields">
            <summary>
                Export all fields automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.DefaultMethodCodeGenerator">
            <summary>
                Reference to code geenrator which will be applied to every method
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.AutoExportConstructors">
            <summary>
                When true, code for all constructors will be automatically generated
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsClassAttribute.IsAbstract">
            <summary>
            Gets or sets whether class is being exported as abstract or not.
            Null value means automatic detection
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsDeclarationAttributeBase">
            <summary>
                Base attribute for so-called compilation unit (class, enum, interface etc)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.#ctor">
            <summary>
                Constructs new instance of TsDeclarationAttributeBase
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.IncludeNamespace">
            <summary>
                Place to corresponding namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.Namespace">
            <summary>
                Overrides namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.Name">
            <summary>
                Overrides name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.Order">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.FlattenHierarchy">
            <summary>
            Gets or sets whether to generate properties/methods flattering inheritance hierarchy
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDeclarationAttributeBase.FlattenLimiter">
            <summary>
            Flattering limiter. 
            All types "deeper" than specified parent will not be considered as exporting members donors
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsDecoratorAttribute">
            <summary>
            Adds decorator to class/method/parameter/property
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDecoratorAttribute.Decorator">
            <summary>
            Decorator text - everything that must follow after @
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsDecoratorAttribute.Order">
            <summary>
            Decorator order
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsDecoratorAttribute.#ctor(System.String,System.Double)">
            <summary>
            Creates decorator attribute
            </summary>
            <param name="decorator">Decorator text - everything that follows after @</param>
            <param name="order">Decorator order of appearence</param>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsEnumAttribute">
            <summary>
                Exports enum as TypeScript Enum
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsEnumAttribute.IsConst">
            <summary>
            When true, results "const" enum instead of usual
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsEnumAttribute.UseString">
            <summary>
            Gets or sets whetner enum fields must be exported with string initializers (TypeScript 2.4)
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsFileAttribute">
            <summary>
                Specifies file where to put generated code for type.
                This attribute is being ignored when RtDivideTypesAmongFiles is false.
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsFileAttribute.#ctor(System.String)">
            <summary>
                Constructs new TsFile attribute
            </summary>
            <param name="fileName">File name (related to RtTargetDirectory) where to put generated code</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFileAttribute.FileName">
            <summary>
                File name (related to RtTargetDirectory) where to put generated code
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsFunctionAttribute">
            <summary>
                Overrides function export
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.Order">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.Implementation">
            <summary>
            Inline function code to be converted to RtRaw and used as function body
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.ForceAsync">
            <summary>
            Gets or sets whether function forcibly should be made async/left as usual function
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsFunctionAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsGenericAttribute">
            <summary>
                Denotes type for generic attribute
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsGenericAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsGenericAttribute
            </summary>
            <param name="type">Raw TypeScript type name</param>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsGenericAttribute.#ctor(System.Type)">
            <summary>
                Constructs new instance of TsGenericAttribute
            </summary>
            <param name="strongType">Type to be resolved to TypeScript name during export</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGenericAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsGlobalAttribute">
            <summary>
            Sets global parameters for RT export.
            Warning! Use Priority property to control [TsGlobal] processing order. 
            When exporting multiple assemblies and several ones will contain [TsGlobal] then the one with 
            highest priority will be used. Global parameters configured from fluent configuration 
            using builder.Global method always has highest priority
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.WriteWarningComment">
            <summary>
                Boolean parameter that controls writing of "auto-generated warning" comment to each generated file.
            It meant the comment like "// This code was generated blah blah blah..."
            'true' (default) to write warning comment about auto-generated to every file.
            'false' to do not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.RootNamespace">
            <summary>
                Specifies root namespace for hierarchical export.
                Helps to avoid creating redundant directories when hierarchical export.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.CamelCaseForMethods">
            <summary>
                Use camelCase for methods naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.CamelCaseForProperties">
            <summary>
                Use camelCase for properties naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.GenerateDocumentation">
            <summary>
                Enables or disables documentation generator
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.TabSymbol">
            <summary>
            Specifies symbol used for tabulation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.NewLine">
            <summary>
            Specifies string used as the line terminator.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.UseModules">
            <summary>
            Switches RT to using TS modules system (--module tsc.exe parameter) and import references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.DiscardNamespacesWhenUsingModules">
            <summary>
            When true, RT will ignore classes' namespaces when arraging classes and interfaces among files. 
            This parameter only makes difference when using (--module)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.ExportPureTypings">
            <summary>
                If true, export will be performed in .d.ts manner (only typings, declare module etc).
                Otherwise, export will be performed to regulat .ts file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.Priority">
            <summary>
            Sets order of applying paramters from this attribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.ReferenceProcessorType">
            <summary>
            Type of <see cref="T:Reinforced.Typings.ReferencesInspection.ReferenceProcessorBase"/> to be used to
            refilter/reorder references and imports while exporting files
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.ReorderMembers">
            <summary>
             Gets or sets whether members reordering (aphabetical, constructors-fields-properties-methods) is enabled
             Warning! Enabling this option discards <see cref="M:Reinforced.Typings.Fluent.MemberExportExtensions.Order(Reinforced.Typings.Fluent.MethodExportBuilder,System.Double)"/> calls as well as "Order" member attributes property
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.AutoOptionalProperties">
            <summary>
            Gets or sets whether all nullable properties must be exported as optional
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.UnresolvedToUnknown">
            <summary>
            Gets or sets whether unresolved types must be exported as 'unknown' instead of 'any'
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsGlobalAttribute.#ctor">
            <summary>
            Default constructor for TsGlobal attribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.VisitorType">
            <summary>
            Gets or sets type of AST visitor that will be used to write code to output.
            Visitor has to be child class of <see cref="T:Reinforced.Typings.Visitors.TextExportingVisitor"/>
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsGlobalAttribute.AutoAsync">
            <summary>
            Gets or sets whether RT must automatically treat methods returning Task as async methods
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsIgnoreAttribute">
            <summary>
                Instructs DynTyping do not to export mentioned member
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsImportAttribute">
            <summary>
                Specifies path of reference which required to be added to result .ts file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsImportAttribute.ImportTarget">
            <summary>
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsImportAttribute.ImportSource">
            <summary>
            Import source is everything that follows after "from" keyword. 
            Please not the you do not have to specify quotes here! Quotes will be added automatically
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsImportAttribute.ImportRequire">
            <summary>
            When true, import will be generated as "import ImportTarget = require('ImportSource')"
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsInterfaceAttribute">
            <summary>
                Exports specified class or interface as typescript interface
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsInterfaceAttribute.#ctor">
            <summary>
                Constructs new instance of TsInterfaceAttribute
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsInterfaceAttribute.AutoI">
            <summary>
                Automatically appends I prefix if non-interfaces
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsInterfaceAttribute.AutoExportMethods">
            <summary>
                Export all methods automatically or not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsInterfaceAttribute.AutoExportProperties">
            <summary>
                Export all properties automatically or not.
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsParameterAttribute">
            <summary>
                Overrides settings for exporting parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsParameterAttribute.DefaultValue">
            <summary>
                Specifies default value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsParameterAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsPropertyAttribute">
            <summary>
                Overrides property/field export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsPropertyAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.NilForceNullable">
            <summary>
                Forces property to be a nullable
                E.g. `field:boolean` becomes `field?:boolean` when you specify `[TsProperty(ForceNullable = true)]` in attribute configuration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.ForceNullable">
            <summary>
                Forces property to be a nullable
                E.g. `field:boolean` becomes `field?:boolean` when you specify `[TsProperty(ForceNullable = true)]` in attribute configuration
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.Order">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.Constant">
            <summary>
            When true, static property with well-known simple static value will be exported as object property with corresponding static initializer. 
            Otherwise, setting this parameter to "true" will not take effect
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsPropertyAttribute.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsReferenceAttribute">
            <summary>
                Specifies path of reference which required to be added to result .ts file
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsReferenceAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsReferenceAttribute
            </summary>
            <param name="path">Path that should be written as file to reference tag</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsReferenceAttribute.Path">
            <summary>
                Path to referenced TS file
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsThirdPartyAttribute">
            <summary>
            Prevents class or interface or enum to be exported.
            Instead of that it will be used like type from third-party library.
            Use <see cref="T:Reinforced.Typings.Ast.Dependency.RtReference"/> and <see cref="T:Reinforced.Typings.Ast.Dependency.RtImport"/> attributes to specify imports that must be used
            when this type appears
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsThirdPartyAttribute.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsThirdPartyAttribute.Name">
            <summary>
            Gets or sets full quialified name of third party type to avoid dealing with namespaces, I letters etc
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsThirdPartyImportAttribute">
            <summary>
                This attribute is used to add import directive to any file using third-party type (that is marked with <see cref="T:Reinforced.Typings.Attributes.TsThirdPartyAttribute"/>)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsThirdPartyImportAttribute.ImportTarget">
            <summary>
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsThirdPartyImportAttribute.ImportSource">
            <summary>
            Import source is everything that follows after "from" keyword. 
            Please note that you do not have to specify quotes here! Quotes will be added automatically
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsThirdPartyImportAttribute.ImportRequire">
            <summary>
            When true, import will be generated as "import ImportTarget = require('ImportSource')"
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsThirdPartyImportAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Cosntructs new Rtimport
            </summary>
            <param name="importTarget">Target</param>
            <param name="importSource">Source</param>
            <param name="importRequire">Is import "=require(...)"</param>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsThirdPartyReferenceAttribute">
            <summary>
                This attribute is used to add reference directive to file using third-party type (that is marked with <see cref="T:Reinforced.Typings.Attributes.TsThirdPartyAttribute"/>)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Attributes.TsThirdPartyReferenceAttribute.#ctor(System.String)">
            <summary>
                Constructs new instance of TsAddTypeReferenceAttribute using referenced type
            </summary>
            <param name="path">Raw reference</param>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsThirdPartyReferenceAttribute.Path">
            <summary>
                Raw reference path that will be added to target file
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsTypedAttributeBase">
            <summary>
                Base attribute for typed members/parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedAttributeBase.Type">
            <summary>
                Overrides member type name in resulting TypeScript. 
                Supplied as string. Helpful when property type is not present in your project. 
                E.g. - JQquery object.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedAttributeBase.StrongType">
            <summary>
                Similar to `Type`, but you can specify .NET type using typeof. 
                It is useful e.g. for delegates
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase">
            <summary>
                Base attribute for class members and method parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase.ShouldBeCamelCased">
            <summary>
                When true them member name will be camelCased regardless configuration setting
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase.ShouldBePascalCased">
            <summary>
                When true them member name will be PascalCased regardless configuration setting
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsTypedMemberAttributeBase.Name">
            <summary>
                Overrides member name
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Attributes.TsValueAttribute">
            <summary>
                Specifies exporting enum value
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsValueAttribute.Name">
            <summary>
                Overrides enum value name
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Attributes.TsValueAttribute.Initializer">
            <summary>
            Overrides enum value's string initializer. This property works only if there is <see cref="P:Reinforced.Typings.Attributes.TsEnumAttribute.UseString"/> property set to true.
            Please escape quotes manually.
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.ErrorMessage">
            <summary>
            Data object for RT error message
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.ErrorMessage.Code">
            <summary>
            Error code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.ErrorMessage.MessageText">
            <summary>
            Message test
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.ErrorMessage.Subcategory">
            <summary>
            Error message subcategory (for Visual Studio)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Exceptions.ErrorMessage.Throw(System.Object[])">
            <summary>
            Throws error message as exception
            </summary>
            <param name="formatParameters">Format arguments</param>
            <exception cref="T:Reinforced.Typings.Exceptions.RtException">RtException corresponding to error message will be thrown in all cases</exception>
        </member>
        <member name="M:Reinforced.Typings.Exceptions.ErrorMessage.Warn(System.Object[])">
            <summary>
            Converts error message to RtWarning to be processed further
            </summary>
            <param name="formatParameters"></param>
            <returns></returns>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.ErrorMessages">
            <summary>
            This class contains all RT's error and siagnostic messages. 
            Why didnt I use resources? I dont want to add one more .dll to RT's NuGet package. 
            if localization will be required through issues then I will add one
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0001_TempFileError">
            <summary>
            Could not acquire temporary file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0002_DeployingFilesError">
            <summary>
            Could not replace source file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0003_GeneratorInstantiate">
            <summary>
            Could not instantiate code generator {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0004_GeneratorError">
            <summary>
            Code generator {0} has thrown an error: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0005_TypeResolvationError">
            <summary>
            Could not resolve type for {0}. An error occured: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0006_FluentSingleError">
            <summary>
            Exception thrown when applying fluent configuration method for {1} '{2}': {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0007_FluentBatchError">
            <summary>
            Exception thrown when applying fluent configuration method for collection of {1}: {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0008_FluentWithMethodError">
            <summary>
            MethodCallExpression should be provided for .WithMethod call. Please use only lamba expressions in this place.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0009_FluentWithMethodCouldNotParse">
            <summary>
            Sorry, but {0} is not very good idea for parameter configuration. Try using simplier lambda expression.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0010_PropertyLambdaExpected">
            <summary>
            Property lambda expression expected in {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0011_FieldLambdaExpected">
            <summary>
            Field lambda expression expected in {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0012_NewExpressionLambdaExpected">
            <summary>
            NewExpression should be provided for .WithConstructor call. Please use only lamba expressions in this place.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0013_InvalidField">
            <summary>
            Error when trying to locate particular field
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0014_InvalidProperty">
            <summary>
            Error when trying to locate particular property
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0015_CannotFlatten">
            <summary>
            Error when trying to locate particular property
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0016_InvalidRefProcessorType">
            <summary>
            Error when trying to specify invalid references processor type
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0017_FluentContradict">
            <summary>
            Contradictious export instructions: class {0} cannot be exported as {1} because it is already exported as something else
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTE0018_FluentThirdParty">
            <summary>
            Contradictious export instructions: class {0} cannot be exported as {1} because it is already exported as something else
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0001_DocumentationNotSupplied">
            <summary>
            XMLDOC file not supplied
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0002_DocumentationNotFound">
            <summary>
            Could not find XMLDOC file {0}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0003_TypeUnknown">
            <summary>
            Could not find suitable TypeScript type for {0}. 'any' assumed.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0004_DefaultSuperCall">
            <summary>
            No suitable base constructor found for {0}. Generating 'super' call with all nulls.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0005_BaseClassExportingAsInterface">
            <summary>
            Class {0} (base for {1}) is exported as interface. It is potentially unsafe facility.
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0006_DocumentationParseringError">
            <summary>
            Error parsering XMLDOC file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0007_InvalidDictionaryKey">
            <summary>
            Error parsering XMLDOC file {0}: {1}
            </summary>
        </member>
        <member name="F:Reinforced.Typings.Exceptions.ErrorMessages.RTW0008_TypeloadException">
            <summary>
            Error of type loding
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.RtException">
            <summary>
            Base class for RT exception. 
            All the RT exceptions will be provided to VisualStudio's errors tab
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtException.Code">
            <summary>
            Internal error code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtException.Subcategory">
            <summary>
            Error subcategory
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Exceptions.RtException.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs new RT exception
            </summary>
            <param name="message">Error message</param>
            <param name="code">Error code</param>
            <param name="subcategory">Error subcategory (optional)</param>
        </member>
        <member name="T:Reinforced.Typings.Exceptions.RtWarning">
            <summary>
            Represents warning message that could be displayed during build. 
            Warnings can be added to global warnings collection located at ExportContext.Warnings. 
            ExportContext instance can be found inside every TsCodeGeneratorBase
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtWarning.Code">
            <summary>
            Warning code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtWarning.Subcategory">
            <summary>
            Warning subcategory
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Exceptions.RtWarning.Text">
            <summary>
            Warning detailed text
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Exceptions.RtWarning.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Instantiates new RtWarning that is suitable be added to warnings collection.  
            </summary>
            <param name="code">Warning code</param>
            <param name="subcategory">Warning subcategory (optional). Important! Warning subcategory should not contain word "warning" and ":" symbol</param>
            <param name="text">Warning text</param>
        </member>
        <member name="T:Reinforced.Typings.ExportContext">
            <summary>
                TsExport exporting settings
            </summary>
            <summary>
                TsExport exporting settings
            </summary>
            <summary>
                TsExport exporting settings
            </summary>
            <summary>
                TsExport exporting settings
            </summary>
            <summary>
                TsExport exporting settings
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Hierarchical">
            <summary>
                True to create project hierarchy in target folder.
                False to store generated typings in single file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.TargetDirectory">
            <summary>
                Target directory where to store generated typing files.
                This parameter is not used when Hierarcy is false
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.TargetFile">
            <summary>
                Target file where to store generated sources.
                This parameter is not used when Hierarchy is true
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.ConfigurationMethod">
            <summary>
                Fluent configuration method
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.DocumentationFilePath">
            <summary>
                Path to assembly's XMLDOC file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.SuppressedWarningCodes">
            <summary>
                Gets or sets the list of suppressed warning codes
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ExportContext.#ctor(System.Reflection.Assembly[],Reinforced.Typings.IFilesOperations)">
            <summary>
            Instantiates new ExportContext instance (only for testing/integration)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.SpecialCase">
            <summary>
                There is a case when you are exporting base class as interface. It may lead to some unusual handling of generation,
                so I'm using this property to denote such cases and fix it in-place
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ExportContext.GetPathForType(System.Type,System.Boolean)">
            <summary>
            Retrieves full path to file where specified type will be exported to
            </summary>
            <param name="t">Type</param>
            <param name="stripExtension">Remove file extension. Set to false if you still want to get path with extension in case of module export</param>
            <returns>Full path to file containing exporting type</returns>
        </member>
        <member name="M:Reinforced.Typings.ExportContext.CreateExportedFile(System.String)">
            <summary>
            Sets up exported file dummy
            </summary>
            <param name="fileName">File name</param>
            <returns>Exported file dummy</returns>
        </member>
        <member name="M:Reinforced.Typings.ExportContext.AddWarning(Reinforced.Typings.Exceptions.RtWarning)">
            <summary>
            Adds export-time warning that will be raised to the common warnings list ar the end
            </summary>
            <param name="warning">Warning instance</param>
        </member>
        <member name="M:Reinforced.Typings.ExportContext.ClearWarnings">
            <summary>
            Clears warnings list
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.FileOperations">
            <summary>
            File I/O operations frontend
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Location">
            <summary>
            Identifies where current export is performed in terms of AST. 
            Context.Location could be used to conditionally add members to different places of generated source code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.SourceAssemblies">
            <summary>
                Gets the assemblies to extract typings from.
                Important! TsExporter do not perform any job for loading assemblies. It is left upon a calling side.
                That is because loading assemblies is highly dependent on calling side's AppDomain.
                TsExporter shouldnt handle all this shit
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Documentation">
            <summary>
                Documentation manager
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Warnings">
            <summary>
            Warnings that should be displayed after build. 
            Feel free to add messages from generators here.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.CurrentBlueprint">
            <summary>
            Blueprint of type currently being exported
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Global">
            <summary>
            Global generation parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Generators">
            <summary>
            Generators cache
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportContext.Project">
            <summary>
            Project blueprint
            </summary>
        </member>
        <member name="T:Reinforced.Typings.ExportedFile">
            <summary>
            Resulting TS file model
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ExportedFile.#ctor(System.Collections.Generic.HashSet{System.Type},System.String,Reinforced.Typings.ReferencesInspection.InspectedReferences,Reinforced.Typings.ExportContext)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.References">
            <summary>
            File references and imports
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.Namespaces">
            <summary>
            Namespaces ASTs
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.TypeResolver">
            <summary>
            Type Resolver object
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.AllTypesIsSingleFile">
            <summary>
            Gets or sets whether all exported types are stored in single file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.TypesToExport">
            <summary>
            Set of types being exported within this file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.FileName">
            <summary>
            Absolute file path+name+extension
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.FinalReferences">
            <summary>
            Gets final version of references (after conditional user processing)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ExportedFile.FinalImports">
            <summary>
            Gets final version of references (after conditional user processing)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ExportedFile.EnsureImport(System.Type,System.String)">
            <summary>
            Ensures that imports for specified type presents in specified file
            </summary>
            <param name="t">Type to import</param>
            <param name="typeName">Type name (probably overriden)</param>
            <returns>Import AST node or null if no import needed. Returns existing import in case if type is already imported</returns>
        </member>
        <member name="M:Reinforced.Typings.ExportedFile.EnsureReference(System.Type)">
            <summary>
            Ensures that reference for specified type presents in specified file
            </summary>
            <param name="t">Type to reference</param>
            <returns>Reference AST node or null if no reference needed. Returns existing reference in case if type is already referenced</returns>
        </member>
        <member name="T:Reinforced.Typings.FilesOperations">
            <summary>
            Implementation of file operations abstraction
            </summary>
        </member>
        <member name="P:Reinforced.Typings.FilesOperations.Context">
            <summary>
            <inheritdoc />
            </summary>
        </member>
        <member name="M:Reinforced.Typings.FilesOperations.DeployTempFiles">
            <summary>
            <inheritdoc />
            </summary>
        </member>
        <member name="M:Reinforced.Typings.FilesOperations.ExportCore(System.IO.StreamWriter,Reinforced.Typings.ExportedFile)">
            <summary>
            Internal implementation of file Export operation
            </summary>
            <param name="tw">Target stream</param>
            <param name="file">Exported file</param>
        </member>
        <member name="M:Reinforced.Typings.FilesOperations.Export(System.String,Reinforced.Typings.ExportedFile)">
            <summary>
            <inheritdoc />
            </summary>
        </member>
        <member name="M:Reinforced.Typings.FilesOperations.ClearTempRegistry">
            <summary>
            <inheritdoc />
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ConfigurationBuilder">
            <summary>
                Fluent configuration builder
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ConfigurationBuilder.Context">
            <summary>
            Export context
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ConfigurationBuilderExtensions">
            <summary>
            Set of extensions for configuration builder
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuilderExtensions.AddReference(Reinforced.Typings.Fluent.ConfigurationBuilder,System.String)">
            <summary>
                Adds global reference to another typescript library
            </summary>
            <param name="conf">Table configurator</param>
            <param name="path">Full path to .d.ts or .ts file</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuilderExtensions.AddImport(Reinforced.Typings.Fluent.ConfigurationBuilder,System.String,System.String,System.Boolean)">
            <summary>
                Adds import directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="conf">Configurator</param>
            <param name="target">
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </param>
            <param name="from">
            Import source is everything that follows after "from" keyword. 
            Please not the you do not have to specify quotes here! Quotes will be added automatically
            </param>
            <param name="isRequire">When true, import will be generated as "import ImportTarget = require('ImportSource')"</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuilderExtensions.Substitute(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Type,Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Defines global type substitution. Substituted type will be strictly replaced with substitution during export
            </summary>
            <param name="builder"></param>
            <param name="substitute">Type to substitute</param>
            <param name="substitution">Substitution for type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuilderExtensions.SubstituteGeneric(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Type,System.Func{System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Defines global generic type substitution. Substituted type will be strictly replaced with substitution during export
            </summary>
            <param name="builder"></param>
            <param name="genericType">Type to substitute</param>
            <param name="substitutionFn">Substitution for type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ConfigurationBuilderExtensions.TryLookupDocumentationForAssembly(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Reflection.Assembly,System.String)">
            <summary>
                Tries to find documentation .xml file for specified assembly and take it in account when generating documentaion
            </summary>
            <param name="conf">Table configurator</param>
            <param name="assmbly">Assembly which documentation should be included</param>
            <param name="documentationFileName">Override XMLDOC file name if differs (please include .xml extension)</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.GlobalConfigurationBuilder">
            <summary>
            Global configuration builder
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.GlobalConfigurationExtensions">
            <summary>
            Set of extensions for global configuration
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.Global(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Action{Reinforced.Typings.Fluent.GlobalConfigurationBuilder})">
            <summary>
            Configures global exporting parameters
            </summary>
            <param name="builder">Conf builder</param>
            <param name="config">Global configuration action</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.DontWriteWarningComment(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Disables writing of "auto-generated warning" comment to each generated file.
            It meant the comment like "// This code was generated blah blah blah..."
            </summary>
            <param name="builder">Conf builder</param>
            <param name="dontWrite">Pass 'true' (default) to disable adding warning comment to target file. Pass 'false' to leave this label in place.</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.TabSymbol(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.String)">
            <summary>
            Changes indentation symbol (by default is \t). 
            This ability is made by @jonsa's request - boring perfectionist
            </summary>
            <param name="builder">Conf builder</param>
            <param name="symbol">New indentation symbol</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.NewLine(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.String)">
            <summary>
            Changes line termination string. Default is <see cref="P:System.Environment.NewLine"/>.
            </summary>
            <param name="builder">Conf builder</param>
            <param name="newLine">String that used as the line terminator.</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.RootNamespace(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.String)">
            <summary>
                Specifies root namespace for hierarchical export.
                Helps to avoid creating redundant directories when hierarchical export.
            </summary>
            <param name="builder">Conf builder</param>
            <param name="rootNamespace">Application root namespace</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.CamelCaseForMethods(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Use camelCase for methods naming
            </summary>
            <param name="builder">Conf builder</param>
            <param name="cameCase">Pass 'true' to convert all MethodsNames to camelCase </param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.CamelCaseForProperties(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Use camelCase for properties naming
            </summary>
            <param name="builder">Conf builder</param>
            <param name="cameCase">Pass 'true' to convert all MethodsNames to camelCase </param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.GenerateDocumentation(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Enables documentation generator
            </summary>
            <param name="builder">Conf builder</param>
            <param name="generate">Pass 'true' to generate JSDOC for exported types from XMLDOC</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.UseModules(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean,System.Boolean)">
            <summary>
            Enables adaptation for TS modules system (--modules tsc.exe option)
            </summary>
            <param name="builder">Conf builder</param>
            <param name="useModules">True will enable usage of modules system and exports/imports</param>
            <param name="discardNamespaces">True will automatically ignore namespaces while exporting types</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.ExportPureTypings(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
             If true, export will be performed in .d.ts manner (only typings, declare module etc).
             Otherwise, export will be performed to regulat .ts file
            </summary>
            <param name="builder">Conf builder</param>
            <param name="typings">Enables or disables option</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.WithReferencesProcessor``1(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
             Sets rype of <see cref="T:Reinforced.Typings.ReferencesInspection.ReferenceProcessorBase"/> to be used to
            refilter/reorder references and imports while exporting files
            </summary>
            <typeparam name="T">Type of references processor to be used</typeparam>
            <param name="builder">Conf builder</param>
            <param name="use">When false then disables usage of references processor</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.ReorderMembers(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
             Enables or disables exporting members reordering (aphabetical, constructors-fields-properties-methods).
             Warning! Enabling this option discards <see cref="M:Reinforced.Typings.Fluent.MemberExportExtensions.Order(Reinforced.Typings.Fluent.MethodExportBuilder,System.Double)"/> calls as well as "Order" member attributes property
            </summary>
            <param name="builder">Conf builder</param>
            <param name="reorder">True to reorder exported members alphabetically, false otherwise</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.UseVisitor``1(Reinforced.Typings.Fluent.GlobalConfigurationBuilder)">
            <summary>
             Sets override of type of AST visitor that will be used to write code to output.
            Warning! This option overrides <see cref="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.ExportPureTypings(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)"/> configuration!
            </summary>
            <param name="builder">Conf builder</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.AutoOptionalProperties(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
             Tells RT to make all nullable value-type properties optional automatically
            </summary>
            <param name="builder">Conf builder</param>
            <param name="autoOptional">True to export make all nullable-typed properties optional</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.UnresolvedToUnknown(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
            Makes RT to export unresolved types as 'unknown' instead of 'any'
            </summary>
            <param name="builder">Conf builder</param>
            <param name="unresolvedToUnknown">True to export unresolved types as 'unknown', false to export as 'any'</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.GlobalConfigurationExtensions.AutoAsync(Reinforced.Typings.Fluent.GlobalConfigurationBuilder,System.Boolean)">
            <summary>
                Makes RT automatically to turn methods returning Task into async ones
            </summary>
            <param name="builder">Conf builder</param>
            <param name="value">True to enable the feature</param>
        </member>
        <member name="T:Reinforced.Typings.Fluent.InferringExtensions">
            <summary>
            Set of extensions for inline inferring
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InferringExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,Reinforced.Typings.TypeResolver,System.String})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InferringExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InferringExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,System.String})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InferringExtensions.InferType``1(Reinforced.Typings.ISupportsInferring{``0},System.Func{``0,Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Overrides type resolver for member type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x">Inferrable</param>
            <param name="inferrer">Type inferer</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.LambdaHelpers">
            <summary>
                Set of helper reflection methods
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParsePropertyLambda``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <typeparam name="T1">T1</typeparam>
            <typeparam name="T2">T2</typeparam>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParsePropertyLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseFieldLambda``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <typeparam name="T1">T1</typeparam>
            <typeparam name="T2">T2</typeparam>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseFieldLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves PropertyInfo from it
            </summary>
            <param name="lambda">Property Lambda expression</param>
            <returns>PropertyInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseMethodLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves MethodInfo from it
            </summary>
            <param name="lambda">Method lambda expression</param>
            <returns>MethodInfo referenced by this expression</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.LambdaHelpers.ParseConstructorLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
                Parses supplied lambda expression and retrieves ConstructorInfo from it
            </summary>
            <param name="lambda">Constructor lambda expression ( => new Obejct(Ts.Parameter...))</param>
            <returns>Constructor referenced by this expression</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.MemberExportBuilder">
            <summary>
            Fluent export configuration builder for Type Member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportBuilder.#ctor(Reinforced.Typings.TypeBlueprint,System.Reflection.MemberInfo)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.EnumValueExportBuilder">
            <summary>
            Fluent export configuration builder for enum value
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.EnumValueExportBuilder.#ctor(Reinforced.Typings.TypeBlueprint,System.Reflection.FieldInfo)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.EnumValueExportBuilder.Member">
            <summary>
            Gets value being configured
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.FieldExportBuilder">
            <summary>
            Fluent export configuration builder for a field
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.FieldExportBuilder.#ctor(Reinforced.Typings.TypeBlueprint,System.Reflection.MemberInfo)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.FieldExportBuilder.Member">
            <summary>
            Gets property being configured
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.MethodExportBuilder">
            <summary>
            Fluent export configuration builder for method
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MethodExportBuilder.#ctor(Reinforced.Typings.TypeBlueprint,System.Reflection.MemberInfo)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.MethodExportBuilder.Member">
            <summary>
            Gets method being configured
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.MethodExportBuilder.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ParameterExportBuilder">
            <summary>
            Fluent export configuration builder for method parameter
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ParameterExportBuilder.Member">
            <summary>
            Gets parameter being configured
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ParameterExportBuilder.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.PropertyExportBuilder">
            <summary>
            Fluent export configuration builder for property or field
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.PropertyExportBuilder.#ctor(Reinforced.Typings.TypeBlueprint,System.Reflection.MemberInfo)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.PropertyExportBuilder.Member">
            <summary>
            Gets property being configured
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.PropertyExportBuilder.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.MemberExportExtensions">
            <summary>
            Extensions for members export configuration
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.CamelCase``1(``0)">
            <summary>
                Forces member name to be camelCase
            </summary>
            <param name="conf">Configuration</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.PascalCase``1(``0)">
            <summary>
                Forces member name to be PascalCase
            </summary>
            <param name="conf">Configuration</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Decorator(Reinforced.Typings.Fluent.MemberExportBuilder,System.String,System.Double)">
            <summary>
            Adds decorator to member
            </summary>
            <param name="conf">Member configurator</param>
            <param name="decorator">Decorator to add (everything that must follow after "@")</param>
            <param name="order">Order of appearence</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.OverrideName(Reinforced.Typings.Fluent.MemberExportBuilder,System.String)">
            <summary>
                Overrides name of exported type
            </summary>
            <param name="conf">Configuration</param>
            <param name="name">Custom name to be used</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Type(Reinforced.Typings.Fluent.MemberExportBuilder,System.String)">
            <summary>
                Overrides member type name on export with textual string.
                Beware of using this setting because specified type may not present in your TypeScript code and
                this will lead to TypeScript compilation errors
            </summary>
            <param name="conf">Configurator</param>
            <param name="typeName">TS-friendly type name</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Type``1(Reinforced.Typings.Fluent.MemberExportBuilder)">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
            </summary>
            <param name="conf">Configurator</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Type(Reinforced.Typings.Fluent.MemberExportBuilder,System.Type)">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
            </summary>
            <param name="conf">Configurator</param>
            <param name="type">Type to override with</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Ignore(Reinforced.Typings.Fluent.MemberExportBuilder)">
            <summary>
                Ignores specified members during exporting
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Decorator(Reinforced.Typings.Fluent.EnumValueExportBuilder,System.String,System.Double)">
            <summary>
            Adds decorator to member
            </summary>
            <param name="conf">Member configurator</param>
            <param name="decorator">Decorator to add (everything that must follow after "@")</param>
            <param name="order">Order of appearence</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.OverrideName(Reinforced.Typings.Fluent.EnumValueExportBuilder,System.String)">
            <summary>
                Overrides name of exported type
            </summary>
            <param name="conf">Configuration</param>
            <param name="name">Custom name to be used</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Ignore(Reinforced.Typings.Fluent.EnumValueExportBuilder,System.Boolean)">
            <summary>
                Ignores specified mambers during exporting
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.MethodExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Order(Reinforced.Typings.Fluent.MethodExportBuilder,System.Double)">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
            <param name="conf">Configurator</param>
            <param name="order">Order of member</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Implement(Reinforced.Typings.Fluent.MethodExportBuilder,System.String)">
            <summary>
            Sets function body (works in case of class export) that will be converted to RtRaw and inserted as code block
            </summary>
            <param name="builder"></param>
            <param name="functionCode">Function code</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Returns(Reinforced.Typings.Fluent.MethodExportBuilder,System.String)">
            <summary>
                Overrides member type name on export with textual string.
                Beware of using this setting because specified type may not present in your TypeScript code and
                this will lead to TypeScript compilation errors.
                Actually this method does the same as .Type call. Just for your convinence
            </summary>
            <param name="conf">Configurator</param>
            <param name="typeName">TS-friendly type name</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Returns``1(Reinforced.Typings.Fluent.MethodExportBuilder)">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
                Actually this method does the same as .Type call. Just for your convinence
            </summary>
            <param name="conf">Configurator</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Returns(Reinforced.Typings.Fluent.MethodExportBuilder,System.Type)">
            <summary>
                Overrides member type on export with strong type.
                Feel free to use delegates here. It is very comfortable instead of regular TS functions syntax.
                Actually this method does the same as .Type call. Just for your convinence
            </summary>
            <param name="conf">Configurator</param>
            <param name="type">Type to override with</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.ForceAsync(Reinforced.Typings.Fluent.MethodExportBuilder,System.Nullable{System.Boolean})">
            <summary>
                Specifies whether exported method must be considered async.
                If this value is specified explicitly then exported method will be considered async based on
                this value. If the value is null then RT will automatically decide whether method must be async
                based on its return type (Task`N).
            </summary>
            <param name="conf">Configurator</param>
            <param name="isAsync">True to make method async, false otherwise</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.DefaultValue(Reinforced.Typings.Fluent.ParameterExportBuilder,System.Object)">
            <summary>
                Sets parameter default value.
            </summary>
            <param name="conf">Configuration</param>
            <param name="value">Default value for parameter</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.ParameterExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.PropertyExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.WithFieldCodeGenerator``1(Reinforced.Typings.Fluent.FieldExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Order(Reinforced.Typings.Fluent.PropertyExportBuilder,System.Double)">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
            <param name="conf">Configurator</param>
            <param name="order">Order of member</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.ForceNullable(Reinforced.Typings.Fluent.PropertyExportBuilder,System.Nullable{System.Boolean})">
            <summary>
                Forces property to be a nullable.
                When set to true then property will be generated as [property]? : [type] with
                forcibly added question mark denoting nullable field.
            </summary>
            <param name="conf">Configuration</param>
            <param name="force">Force nullable or not</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.Constant(Reinforced.Typings.Fluent.PropertyExportBuilder,System.Boolean)">
            <summary>
                Forces static property to be exported with constant initializer.
                Works only on numeric/boolean/string/null properties
            </summary>
            <param name="conf">Configuration</param>
            <param name="constant">Switches constant export behavior</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.MemberExportExtensions.InitializeWith(Reinforced.Typings.Fluent.PropertyExportBuilder,System.Func{System.Reflection.MemberInfo,Reinforced.Typings.TypeResolver,System.Object,System.String})">
            <summary>
                Specifies initialization expression evaluator for property
            </summary>
            <param name="conf">Configuration</param>
            <param name="evaluator">
            Initialization expression evaluator. Returns TypeScript code that will be used as initialization expression for 
            particular property
            </param>
        </member>
        <member name="T:Reinforced.Typings.Fluent.Ts">
            <summary>
                Shortcut for method parameters mocking
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.Ts.Parameter``1">
            <summary>
                Parameter mock for specified type
            </summary>
            <typeparam name="T">Parameter type</typeparam>
            <returns>Mock</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.Ts.Parameter``1(System.Action{Reinforced.Typings.Fluent.ParameterExportBuilder})">
            <summary>
                Parameter mock with parameter configuration
            </summary>
            <typeparam name="T">Parameter type</typeparam>
            <param name="configuration">Fluent parameter configuration</param>
            <returns>Mock</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ClassExportBuilder">
            <summary>
            Fluent export configuration builder for class
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions">
            <summary>
            Set of extensions for type export configuration
            </summary>
            <summary>
            Set of extensions for type export configuration
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsClass``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Includes specified type to resulting typing exported as TypeScript class
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsClasses(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.ClassExportBuilder})">
            <summary>
                Includes specified types to resulting typing exported as TypeScript classes
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.Value``1(``0,System.String,System.Action{Reinforced.Typings.Fluent.EnumValueExportBuilder})">
            <summary>
                Configures export of particular enumeration value
            </summary>
            <param name="conf">Configuration builder</param>
            <param name="propertyName">String enum property name</param>
            <param name="valueConf">Enum value export configuration</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.Initializer(Reinforced.Typings.Fluent.EnumValueExportBuilder,System.String)">
            <summary>
            Overrides enum value's string initializer. Please escape quotes manually.
            </summary>
            <param name="conf"></param>
            <param name="initializer"></param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsEnum``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Includes specified type to resulting typing exported as TypeScript enumeration
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsEnums(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.EnumExportBuilder})">
            <summary>
                Includes specified types to resulting typing exported as TypeScript enumerations
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsInterface``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Includes specified type to resulting typing exported as TypeScript class
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsInterfaces(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.InterfaceExportBuilder})">
            <summary>
                Includes specified types to resulting typing exported as TypeScript classes
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsThirdParty``1(Reinforced.Typings.Fluent.ConfigurationBuilder)">
            <summary>
                Makes RT to treat specified type as type from third-party library
            </summary>
            <typeparam name="T">Type to include</typeparam>
            <param name="builder">Configuration builder</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeConfigurationBuilderExtensions.ExportAsThirdParty(Reinforced.Typings.Fluent.ConfigurationBuilder,System.Collections.Generic.IEnumerable{System.Type},System.Action{Reinforced.Typings.Fluent.ThirdPartyExportBuilder})">
            <summary>
                Makes RT to treat specified types as types from third-party library
            </summary>
            <param name="builder">Configuration builder</param>
            <param name="types">Types to include</param>
            <param name="configuration">Configuration to be applied to each type</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ClassOrInterfaceExportBuilder">
            <summary>
            Fluent export configuration builder for class or interface
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassOrInterfaceExportBuilder.WithMethods(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified methods to resulting typing.
            </summary>
            <param name="methods">Methods to include</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassOrInterfaceExportBuilder.WithProperties(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified properties to resulting typing
            </summary>
            <param name="properties">Properties to include</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassOrInterfaceExportBuilder.WithFields(System.Collections.Generic.IEnumerable{System.Reflection.FieldInfo},System.Action{Reinforced.Typings.Fluent.FieldExportBuilder})">
            <summary>
                Include specified fields to resulting typing
            </summary>
            <param name="fields">Fields to include</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ClassExportBuilder`1">
            <summary>
            Fluent export configuration builder for class (generic)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassExportBuilder`1.WithField``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified field to resulting typing
            </summary>
            <param name="field">Field to include</param>
            <param name="configuration">Configuration to be applied to selected field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassExportBuilder`1.WithMethod``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="method">Method to include</param>
            <param name="configuration">configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassExportBuilder`1.WithMethod(System.Linq.Expressions.Expression{System.Action{`0}},System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="method">Method to include</param>
            <param name="configuration">configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.ClassExportBuilder`1.WithProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="property">Property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ITypedExportBuilder`1">
            <summary>
            Generic fluent configuration builder
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.TypeExportBuilder">
            <summary>
            Fluent export configuration builder for type
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.TypeExportBuilder.Type">
            <summary>
            Gets type that is being configured for export
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.EnumExportBuilder">
            <summary>
            Fluent export configuration builder for enum
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.EnumExportBuilder.Value(System.String)">
            <summary>
                Retrieves configuration builder for particular enumeration value
            </summary>
            <param name="propertyName">String enum property name</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.EnumExportBuilder`1">
            <summary>
            Fluent export configuration builder for enum (generic)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.EnumExportBuilder`1.Value(`0)">
            <summary>
                Retrieves configuration builder for particular enumeration value
            </summary>
            <param name="value">Enum value</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.EnumExportBuilder`1.Value(`0,System.Action{Reinforced.Typings.Fluent.EnumValueExportBuilder})">
            <summary>
                Configures export of particular enumeration value
            </summary>
            <param name="value">Enum value</param>
            <param name="valueConf">Enum value export configuration</param>
            <returns>Configuration builder</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.InterfaceExportBuilder">
            <summary>
            Fluent export configuration builder for interface
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.InterfaceExportBuilder`1">
            <summary>
            Fluent export configuration builder for interface (generic)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InterfaceExportBuilder`1.WithField``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified field to resulting typing
            </summary>
            <param name="field">Field to include</param>
            <param name="configuration">Configuration to be applied to selected field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InterfaceExportBuilder`1.WithMethod``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="method">Method to include</param>
            <param name="configuration">configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InterfaceExportBuilder`1.WithMethod(System.Linq.Expressions.Expression{System.Action{`0}},System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="method">Method to include</param>
            <param name="configuration">configuration to be applied to method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.InterfaceExportBuilder`1.WithProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="property">Property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ThirdPartyExportBuilder">
            <summary>
            Fluent export configuration builder for class
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Fluent.ThirdPartyExportBuilder.Type">
            <summary>
            Gets type that is being configured for export
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.ThirdPartyExportBuilder`1">
            <summary>
            Fluent export configuration builder for class (generic)
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Fluent.TypeExportExtensions">
            <summary>
            Set of extensions for types exporting configuration
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.OverrideName(Reinforced.Typings.Fluent.TypeExportBuilder,System.String)">
            <summary>
                Overrides name of exported type
            </summary>
            <param name="conf">Configuration</param>
            <param name="name">Custom name to be used</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.DontIncludeToNamespace``1(``0,System.Boolean)">
            <summary>
                Configures exporter do not to export member to corresponding namespace
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.OverrideNamespace``1(``0,System.String)">
            <summary>
                Configures exporter to export type to specified namespace
            </summary>
            <param name="conf">Configuration</param>
            <param name="nameSpace">Namespace name</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.AddReference``1(``0,System.String)">
            <summary>
                Adds reference directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="configuration">Configurator</param>
            <param name="referenceFile">Path to referenced file</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.AddReference``1(``0,System.Type)">
            <summary>
                Adds reference directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="configuration">Configurator</param>
            <param name="referencedType">Another generated type that should be referenced</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.AddImport``1(``0,System.String,System.String,System.Boolean)">
            <summary>
                Adds import directive to file containing typing for current type
                This method is only used while splitting generated types to different files
            </summary>
            <param name="conf">Configurator</param>
            <param name="target">
            What we are importing from module.
            Everything that is placed after "import" keyword and before "from" or "= require(..)"
            Examples: 
            - "import * as shape from './Shapes'" -> "* as shape" is target <br/>
            - "import { Foo } from 'Bar'" -> "{ Foo }" is target <br/>
            - "import { Bar2 as bar } from 'Baz'" -> "{ Bar2 as bar }" is target <br/>
            If ImportTarget is null then side-effect import will be generated. 
            </param>
            <param name="from">
            Import source is everything that follows after "from" keyword. 
            Please not the you do not have to specify quotes here! Quotes will be added automatically
            </param>
            <param name="isRequire">When true, import will be generated as "import ImportTarget = require('ImportSource')"</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.ExportTo``1(``0,System.String)">
            <summary>
                Overrides target file name where specified name will be exported.
                This option will only be processed when RtDivideTypesAmongFiles is true.
            </summary>
            <param name="configuration">Configurator</param>
            <param name="fileName">Target file path override. Related to RtTargetDirectory</param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.Substitute``1(``0,System.Type,Reinforced.Typings.Ast.TypeNames.RtTypeName)">
            <summary>
            Defines local type substitution that will work only when exporting current class. 
            Substituted type will be strictly replaced with substitution during export but this option will take effect only when 
            exporting currently configurable type
            </summary>
            <param name="builder"></param>
            <param name="substitute">Type to substitute</param>
            <param name="substitution">Substitution for type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.SubstituteGeneric``1(``0,System.Type,System.Func{System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.TypeNames.RtTypeName})">
            <summary>
            Defines local generic type substitution that will work only when exporting current class. 
            Substituted type will be strictly replaced with substitution during export but this option will take effect only when 
            exporting currently configurable type
            </summary>
            <param name="builder"></param>
            <param name="genericType">Type to substitute</param>
            <param name="substitutionFn">Substitution for type</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.WithName``1(``0,System.String)">
            <summary>
             Overrides name of third-party type. Use full-qualified name.
            </summary>
            <param name="builder"></param>
            <param name="fullQualifiedName">Full-qualified name of third-party type</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.References``1(``0,Reinforced.Typings.Ast.Dependency.RtReference[])">
            <summary>
            Specifies set of references that third-party type will add to each file it is being used in
            </summary>
            <param name="builder"></param>
            <param name="references">Set of references</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.Imports``1(``0,Reinforced.Typings.Ast.Dependency.RtImport[])">
            <summary>
            Specifies set of imports that third-party type will add to each file it is being used in
            </summary>
            <param name="builder"></param>
            <param name="imports">Set of imports</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.ClassExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.Abstract``1(``0,System.Nullable{System.Boolean})">
            <summary>
              Configures class to be exported as abstract or not.
              Pass null value to identify automatically
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.WithConstructor``1(``0,Reinforced.Typings.Ast.RtRaw,System.Boolean)">
            <summary>
            Configures class to export constructor
            If constructor body is not specified, then default body will be generated.
            Default body is empty if there are no inheritance.
            If there is inheritance then RT will try to generate optimal super() call 
            that can be controlled by <see cref="T:Reinforced.Typings.Attributes.TsBaseParamAttribute"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conf"></param>
            <param name="exportConstructors">When true, constructor will be exported</param>
            <param name="constructorBody">Optional constructor body implementation</param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.Order(Reinforced.Typings.Fluent.TypeExportBuilder,System.Double)">
            <summary>
            Sets order this membter will be written to output file in
            </summary>
            <param name="conf">Configurator</param>
            <param name="order">Order of member</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.FlattenHierarchy``1(``0,System.Type)">
            <summary>
                Configures exporter to flatten inheritance hierarchy for supplied type
            </summary>
            <param name="conf">Configuration</param>
            <param name="until">
            All classes "deeper" than specified (including) will not be considered as exportable members donors. 
            By default this parameter is equal to typeof(object)
            </param>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.Decorator(Reinforced.Typings.Fluent.TypeExportBuilder,System.String,System.Double)">
            <summary>
            Adds decorator to member
            </summary>
            <param name="conf">Member configurator</param>
            <param name="decorator">Decorator to add (everything that must follow after "@")</param>
            <param name="order">Order of appearence</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.EnumExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.Const``1(``0,System.Boolean)">
            <summary>
            Turns enum to constant enum
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conf">Enum configurator</param>
            <param name="isConst">When true, "const enum" will be generated. Regular enum otherwise</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.UseString``1(``0,System.Boolean)">
            <summary>
            Makes enum to use string initializer for its values (TypeScript 2.4)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conf">Enum configurator</param>
            <param name="useString">When true, enum values will be exported with string initializers</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.WithCodeGenerator``1(Reinforced.Typings.Fluent.InterfaceExportBuilder)">
            <summary>
                Specifies code generator for member
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.TypeExportExtensions.AutoI``1(``0,System.Boolean)">
            <summary>
                Forces exporter to add I letter as interface prefix.
            </summary>
            <param name="conf">Configuration</param>
            <param name="auto">Add I automatically or not</param>
        </member>
        <member name="T:Reinforced.Typings.Fluent.WithExtensions">
            <summary>
            Set of .With-extensions
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithField``2(Reinforced.Typings.Fluent.ITypedExportBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Include specified field to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="field">Field to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithField``1(``0,System.String,System.Action{Reinforced.Typings.Fluent.FieldExportBuilder})">
            <summary>
                Include specified field to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="fieldName">Name of field to include</param>
            <param name="configuration">Configuration to be applied to selected field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithFields``1(``0,System.Func{System.Reflection.FieldInfo,System.Boolean},System.Action{Reinforced.Typings.Fluent.FieldExportBuilder})">
            <summary>
                Include specified fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="predicate">Predicate function that should mathc for fields to include</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithAllFields``1(``0,System.Action{Reinforced.Typings.Fluent.FieldExportBuilder})">
            <summary>
                Include all fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithPublicFields``1(``0,System.Action{Reinforced.Typings.Fluent.FieldExportBuilder})">
            <summary>
                Include all public fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithFields``1(``0,System.Reflection.BindingFlags,System.Action{Reinforced.Typings.Fluent.FieldExportBuilder})">
            <summary>
                Include specified fields to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="bindingFlags">BindingFlags describing fields to include</param>
            <param name="configuration">Configuration to be applied to each field</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithMethod``2(Reinforced.Typings.Fluent.ITypedExportBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithMethod``1(Reinforced.Typings.Fluent.ITypedExportBuilder{``0},System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
                Include specified method to resulting typing.
                User <see cref="M:Reinforced.Typings.Fluent.Ts.Parameter``1" /> to mock up method parameters or specify configuration for perticular method
                parameter
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="method">Method to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithMethods``1(``0,System.Func{System.Reflection.MethodInfo,System.Boolean},System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified methods to resulting typing.
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="predicate">Predicate function that should mathc for methods to include</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithMethods``1(``0,System.Reflection.BindingFlags,System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include specified methods to resulting typing.
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="bindingFlags">BindingFlags describing methods to include</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithAllMethods``1(``0,System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include all methods to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithPublicMethods``1(``0,System.Action{Reinforced.Typings.Fluent.MethodExportBuilder})">
            <summary>
                Include all methods to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each method</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithProperty``2(Reinforced.Typings.Fluent.ITypedExportBuilder{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="property">Property to include</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithProperty``1(``0,System.String,System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified property to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="propertyName">Name of property to include</param>
            <param name="configuration">Configuration to be applied to selected property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithProperties``1(``0,System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="predicate">Predicate function for properties to include</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithProperties``1(``0,System.Reflection.BindingFlags,System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include specified properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="bindingFlags">BindingFlags describing properties to include</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithAllProperties``1(``0,System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include all properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="M:Reinforced.Typings.Fluent.WithExtensions.WithPublicProperties``1(``0,System.Action{Reinforced.Typings.Fluent.PropertyExportBuilder})">
            <summary>
                Include all public properties to resulting typing
            </summary>
            <param name="tc">Configuration builder</param>
            <param name="configuration">Configuration to be applied to each property</param>
            <returns>Fluent</returns>
        </member>
        <member name="T:Reinforced.Typings.GeneratorManager">
            <summary>
            Class for managing and instantiating code generators
            </summary>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorFor``1(``0)">
            <summary>
                Reteieves code generator instance for specified type member.
                Also this method considers Typings attribute and instantiates generator specified there if necessary
            </summary>
            <typeparam name="T">Type member info type</typeparam>
            <param name="member">Type member info</param>
            <returns>Code generator for specified type member</returns>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorFor(System.Reflection.ParameterInfo)">
            <summary>
                Retrieves code generator for ParameterInfo (since ParameterInfo does not derive from MemberInfo).
                Also this method considers Typings attribute and instantiates generator specified there if necessary
            </summary>
            <param name="member">Parameter info</param>
            <returns>Code generator for parameter info</returns>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorFor(System.Type)">
            <summary>
                Retrieves code generator for specified type
                Also this method considers Typings attribute and instantiates generator specified there if necessary
            </summary>
            <param name="member">Type info</param>
            <returns>Code generator for specified type</returns>
        </member>
        <member name="M:Reinforced.Typings.GeneratorManager.GeneratorForNamespace">
            <summary>
                Retrieves code generator for namespaces
            </summary>
            <returns></returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1">
            <summary>
            Base code generator both for TypeScript class and interface
            </summary>
            <typeparam name="TNode">Resulting node type (RtClass or RtInterface)</typeparam>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.Export(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports entire class to specified writer
            </summary>
            <param name="result">Exporting result</param>
            <param name="type">Exporting class type</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportMembers(System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.ITypeMember,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports all type members sequentially
            </summary>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="typeMember">Placeholder for members</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.HandleBaseClassExportingAsInterface(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Here you can customize what to export when base class is class but exporting as interface
            </summary>
            <param name="sw">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportFields(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type fields
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportProperties(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type properties
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportMethods(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type methods
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.ExportConstructors(Reinforced.Typings.Ast.ITypeMember,System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Attributes.IAutoexportSwitchAttribute)">
            <summary>
                Exports type constructors
            </summary>
            <param name="typeMember">Output writer</param>
            <param name="element">Type itself</param>
            <param name="resolver">Type resolver</param>
            <param name="swtch">Pass here type attribute inherited from IAutoexportSwitchAttribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassAndInterfaceGeneratorBase`1.GenerateMembers``1(System.Type,Reinforced.Typings.TypeResolver,Reinforced.Typings.Ast.ITypeMember,System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Exports list of type members
            </summary>
            <typeparam name="T">Type member type</typeparam>
            <param name="element">Exporting class</param>
            <param name="resolver">Type resolver</param>
            <param name="typeMember">Output writer</param>
            <param name="members">Type members to export</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ClassCodeGenerator">
            <summary>
                Default code generator for CLR type (class)
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ClassCodeGenerator.GenerateNode(System.Type,Reinforced.Typings.Ast.RtClass,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ConstructorCodeGenerator">
            <summary>
                Default code generator for constructor
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ConstructorCodeGenerator.GenerateNode(System.Reflection.ConstructorInfo,Reinforced.Typings.Ast.RtConstructor,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ContextExtensions">
            <summary>
                Various extensions for settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.ConditionallyConvertMethodNameToCamelCase(Reinforced.Typings.ExportContext,System.String)">
            <summary>
                Conditionally (based on settings) turns method name to camelCase
            </summary>
            <param name="context">Settings object</param>
            <param name="regularName">Regular method name</param>
            <returns>Method name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.ConditionallyConvertMethodNameToPascalCase(Reinforced.Typings.ExportContext,System.String)">
            <summary>
                Conditionally (based on settings) turns method name to PascalCase
            </summary>
            <param name="context">Settings object</param>
            <param name="regularName">Regular method name</param>
            <returns>Method name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.ContextExtensions.ConditionallyConvertPropertyNameToCamelCase(Reinforced.Typings.ExportContext,System.String)">
            <summary>
                Conditionally (based on settings) turns property name to camelCase
            </summary>
            <param name="context">Settings object</param>
            <param name="regularName">Regular property name</param>
            <returns>Property name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.EnumGenerator">
            <summary>
                Default code generator for enums
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.EnumGenerator.GenerateNode(System.Type,Reinforced.Typings.Ast.RtEnum,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.FieldCodeGenerator">
            <summary>
                Default code generator for fields
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.FieldCodeGenerator.GetType(System.Reflection.MemberInfo)">
            <summary>
                That's it - overriden GetType for property since properties and fields are exported to TypeScript almost same way.
            </summary>
            <param name="mi">Member info (Fields behind)</param>
            <returns>Field type</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.FieldCodeGenerator.GetStaticValue(System.Reflection.MemberInfo)">
            <summary>
            Retrieves static value 
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.InterfaceCodeGenerator">
            <summary>
                Default code generator for interfaces. Derived from class generator since interfaces are very similar to classes in
                TypeScript
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.InterfaceCodeGenerator.GenerateNode(System.Type,Reinforced.Typings.Ast.RtInterface,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ITsCodeGenerator`1">
            <summary>
                TypeScript code generator interface
            </summary>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="P:Reinforced.Typings.Generators.ITsCodeGenerator`1.Context">
            <summary>
                Export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ITsCodeGenerator`1.Generate(`0,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should return corresponding AST node for provided 
                reflection element using source Reflection element and RT's Type Resolver
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.MethodCodeGenerator">
            <summary>
                Default typescript code generator for method
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.MethodCodeGenerator.GenerateNode(System.Reflection.MethodInfo,Reinforced.Typings.Ast.RtFunction,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.MethodCodeGenerator.GetFunctionNameAndReturnType(System.Reflection.MethodInfo,Reinforced.Typings.TypeResolver,System.String@,Reinforced.Typings.Ast.TypeNames.RtTypeName@)">
            <summary>
                Retrieves function name corresponding to method and return type. Fell free to override it.
            </summary>
            <param name="element">Method info</param>
            <param name="resolver">Type resolver</param>
            <param name="name">Resulting method name</param>
            <param name="type">Resulting return type name</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.NamespaceCodeGenerator">
            <summary>
                Default code generator for namespace
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Generators.NamespaceCodeGenerator.Context">
            <summary>
                Export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.NamespaceCodeGenerator.Generate(System.Collections.Generic.IEnumerable{System.Type},System.String,Reinforced.Typings.TypeResolver)">
            <summary>
                Generates namespace source code
            </summary>
            <param name="types">Types list</param>
            <param name="namespaceName">Namespace name</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="T:Reinforced.Typings.Generators.ParameterCodeGenerator">
            <summary>
                Default code generator for method parameter
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.ParameterCodeGenerator.GenerateNode(System.Reflection.ParameterInfo,Reinforced.Typings.Ast.RtArgument,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.ParameterCodeGenerator.GetDefaultValue(System.Reflection.ParameterInfo,Reinforced.Typings.Attributes.TsParameterAttribute)">
            <summary>
                Returns default value for specified parameter info
            </summary>
            <param name="element">Parameter info</param>
            <param name="attr">Parameter attribute</param>
            <returns>Serialized to string default value of type that is exposed by mentioned parameter</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.PropertyCodeGenerator">
            <summary>
                Default code generator for properties
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.PropertyCodeGenerator.GenerateNode(System.Reflection.MemberInfo,Reinforced.Typings.Ast.RtField,Reinforced.Typings.TypeResolver)">
            <summary>
                Main code generator method. This method should write corresponding TypeScript code for element (1st argument) to
                WriterWrapper (3rd argument) using TypeResolver if necessary
            </summary>
            <param name="element">Element code to be generated to output</param>
            <param name="result">Resulting node</param>
            <param name="resolver">Type resolver</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.PropertyCodeGenerator.FillInitialization(System.Reflection.MemberInfo,Reinforced.Typings.Ast.RtField,Reinforced.Typings.TypeResolver,System.Type,Reinforced.Typings.Attributes.TsPropertyAttribute)">
            <summary>
            Fills in initialization expression
            </summary>
            <param name="element">Class member</param>
            <param name="result">Resulting AST</param>
            <param name="resolver">Type resolver</param>
            <param name="memberType">Field/property type</param>
            <param name="attr">Attribute</param>
        </member>
        <member name="M:Reinforced.Typings.Generators.PropertyCodeGenerator.GetStaticValue(System.Reflection.MemberInfo)">
            <summary>
            Retrieves static value 
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.PropertyCodeGenerator.GetType(System.Reflection.MemberInfo)">
            <summary>
                Returns type of specified property. It is useful for overloads sometimes
            </summary>
            <param name="mi">Method Info</param>
            <returns>Property info type</returns>
        </member>
        <member name="T:Reinforced.Typings.Generators.TsCodeGeneratorBase`2">
            <summary>
            Base for strongly-typed code generator with automatical Context.Location handling
            </summary>
            <typeparam name="T">Source reflection [Something]Info type. Possible: Type, MethodInfo, PropertyInfo, ConstructorInfo, FieldInfo</typeparam>
            <typeparam name="TNode">Resulting node type</typeparam>
        </member>
        <member name="P:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.Context">
            <summary>
             Export settings
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.Generate(`0,Reinforced.Typings.TypeResolver)">
            <summary>
            Generate method implementation. 
            Calls GenerateNode inside, creates node dummy, sets and resets location
            </summary>
            <param name="element">Reflection element instance</param>
            <param name="resolver">Type resolver</param>
            <returns>Generated node or null</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.GenerateNode(`0,`1,Reinforced.Typings.TypeResolver)">
            <summary>
            Main entry point for resulting node generation.  
            </summary>
            <param name="element">Reflection element</param>
            <param name="node">Resulting node to be modified</param>
            <param name="resolver">Type resolver</param>
            <returns>Resulting node or null</returns>
        </member>
        <member name="M:Reinforced.Typings.Generators.TsCodeGeneratorBase`2.AddDecorators(Reinforced.Typings.Ast.IDecoratable,System.Collections.Generic.IEnumerable{Reinforced.Typings.Attributes.TsDecoratorAttribute})">
            <summary>
            Appends decorators to decoratable node
            </summary>
            <param name="node">Decoratable syntax node</param>
            <param name="decorators">Set of decorator attributes</param>
        </member>
        <member name="T:Reinforced.Typings.GlobalParameters">
            <summary>
            Collections of global TS generation parameters
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.WriteWarningComment">
            <summary>
                Boolean parameter that controls writing of "auto-generated warning" comment to each generated file.
            It meant the comment like "// This code was generated blah blah blah..."
            'true' (default) to write warning comment about auto-generated to every file.
            'false' to do not.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.RootNamespace">
            <summary>
                Specifies root namespace for hierarchical export.
                Helps to avoid creating redundant directories when hierarchical export.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.CamelCaseForMethods">
            <summary>
                Use camelCase for methods naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.CamelCaseForProperties">
            <summary>
                Use camelCase for properties naming
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.GenerateDocumentation">
            <summary>
                Enables or disables documentation generator
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.AutoOptionalProperties">
            <summary>
               Gets or sets whether all nullable properties must be exported as optional
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.TabSymbol">
            <summary>
            Specifies symbol used for tabulation
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.NewLine">
            <summary>
            Specifies string used as the line terminator.
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.UseModules">
            <summary>
            Switches RT to using TS modules system (--module) parameter and import references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.DiscardNamespacesWhenUsingModules">
            <summary>
            When true, RT will ignore classes' namespaces when arraging classes and interfaces among files. 
            This parameter only makes difference when using (--module)
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.ExportPureTypings">
            <summary>
                If true, export will be performed in .d.ts manner (only typings, declare module etc).
                Otherwise, export will be performed to regular .ts file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.ReferencesProcessorType">
            <summary>
            Gets or sets type of <see cref="T:Reinforced.Typings.ReferencesInspection.ReferenceProcessorBase"/> to be used while exporting files
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.ReorderMembers">
            <summary>
                Gets or sets whether it is needed to sort exported members alphabetically
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.VisitorType">
            <summary>
            Gets or sets type of AST visitor that will be used to write code to output.
            Visitor has to be child class of <see cref="T:Reinforced.Typings.Visitors.TextExportingVisitor"/>
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.UnresolvedToUnknown">
            <summary>
            Gets or sets whether unresolved types must be exported as 'unknown' instead of 'any'
            </summary>
        </member>
        <member name="P:Reinforced.Typings.GlobalParameters.AutoAsync">
            <summary>
            Gets or sets whether RT must automatically treat methods returning Task as async methods
            </summary>
        </member>
        <member name="T:Reinforced.Typings.IFilesOperations">
            <summary>
            Interface of files operator
            It has to be public for testing purposes
            </summary>
        </member>
        <member name="P:Reinforced.Typings.IFilesOperations.Context">
            <summary>
            Export context
            </summary>
        </member>
        <member name="M:Reinforced.Typings.IFilesOperations.DeployTempFiles">
            <summary>
            Writes temporary files contents to disk
            </summary>
        </member>
        <member name="M:Reinforced.Typings.IFilesOperations.ClearTempRegistry">
            <summary>
            Cleans up temporary files registry
            </summary>
        </member>
        <member name="M:Reinforced.Typings.IFilesOperations.Export(System.String,Reinforced.Typings.ExportedFile)">
            <summary>
            Exports specified syntax nodes to specified file
            </summary>
            <param name="fileName">File name</param>
            <param name="file">File to be exported</param>
        </member>
        <member name="T:Reinforced.Typings.InlineTypeInferers`1">
            <summary>
            Class holding inline type inferers for specified node
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Reinforced.Typings.ISupportsInferring`1">
            <summary>
            Decorates member that supports inline type inferring
            </summary>
            <typeparam name="T">Member Type</typeparam>
        </member>
        <member name="P:Reinforced.Typings.ISupportsInferring`1.TypeInferers">
            <summary>
            Type inferers set instance
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Location">
            <summary>
            Identifies where current export is performed in terms of AST. 
            Context.Location could be used to conditionally add members to different places of generated source code
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentClass">
            <summary>
            Current Class 
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentInterface">
            <summary>
            Current Interface
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentEnum">
            <summary>
            Current Enum
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentNamespace">
            <summary>
            Current Module
            </summary>
        </member>
        <member name="P:Reinforced.Typings.Location.CurrentType">
            <summary>
            References currently exported type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Location.SetLocation(Reinforced.Typings.Ast.RtNode)">
            <summary>
            Sets current location
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:Reinforced.Typings.Location.ResetLocation(Reinforced.Typings.Ast.RtNode)">
            <summary>
            Sets current location
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:Reinforced.Typings.Location.SetCurrentType(System.Type)">
            <summary>
            Sets currently exported type
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Reinforced.Typings.Location.ResetCurrentType">
            <summary>
            Resets currently exported type
            </summary>
        </member>
        <member name="T:Reinforced.Typings.ProjectBlueprint">
            <summary>
            Class that holds information of all exported types' parameters and helper methods for it
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ProjectBlueprint.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="M:Reinforced.Typings.ProjectBlueprint.Blueprint(System.Type)">
            <summary>
            Returns blueprint for type. Never returns null
            </summary>
            <param name="t">Type</param>
            <returns>Type blueprint</returns>
        </member>
        <member name="M:Reinforced.Typings.ProjectBlueprint.Blueprint(System.Type,System.Boolean)">
            <summary>
            Returns blueprint for type.
            </summary>
            <param name="t">Type</param>
            <param name="create">True to create blueprint if it does not exist</param>
            <returns>Type blueprint</returns>
        </member>
        <member name="P:Reinforced.Typings.ProjectBlueprint.PathesToFiles">
            <summary>
            Dictionary holds pathes to files
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ProjectBlueprint.TypesInFiles">
            <summary>
            Dictionary that holds types within each file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ProjectBlueprint.AdditionalDocumentationPathes">
            <summary>
            Additional pathes to look up documentation for
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ProjectBlueprint.References">
            <summary>
            References that will be added to each exported file
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ProjectBlueprint.Imports">
            <summary>
            Imports that will be added to each exported file
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ProjectBlueprint.Substitute(System.Type,Reinforced.Typings.TypeResolver)">
            <summary>
            Obtains substitution for type
            </summary>
            <param name="t">Type to find substitution for</param>
            <param name="tr">Type resolver instance</param>
            <returns>Substitution AST</returns>
        </member>
        <member name="T:Reinforced.Typings.ReferencesInspection.InspectedReferences">
            <summary>
            Represents inspected references for type or global references
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ReferencesInspection.InspectedReferences.References">
            <summary>
            References exposed via &lt;reference path="..."&gt; tag
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ReferencesInspection.InspectedReferences.Imports">
            <summary>
            References exposed via imports
            </summary>
        </member>
        <member name="P:Reinforced.Typings.ReferencesInspection.InspectedReferences.StarImports">
            <summary>
            Cache of starred imports. Key is "from", value is star import alias
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.#ctor(System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.Dependency.RtReference},System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.Dependency.RtImport})">
            <summary>
            Constructs new inspected references set
            </summary>
            <param name="references">References</param>
            <param name="imports">Imports</param>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.Duplicate">
            <summary>
            Duplicates inspected references for further usage
            </summary>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.AddReference(Reinforced.Typings.Ast.Dependency.RtReference)">
            <summary>
            Attaches new reference to existing ones
            </summary>
            <param name="reference">New reference</param>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.InspectedReferences.AddImport(Reinforced.Typings.Ast.Dependency.RtImport)">
            <summary>
            Attaches new import to existing ones
            </summary>
            <param name="import">Import</param>
        </member>
        <member name="T:Reinforced.Typings.ReferencesInspection.ReferenceProcessorBase">
            <summary>
            Base class for reference post-processor.
            </summary>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.ReferenceProcessorBase.FilterImports(System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.Dependency.RtImport},Reinforced.Typings.ExportedFile)">
            <summary>
            Returns refiltered and reordered import directives that must appear in resulting file.
            Return null to remain references list untouched
            </summary>
            <param name="imports">Set on initially computed imports</param>
            <param name="file">File that is being exported currently</param>
            <returns>Set of refiltered/reordered imports</returns>
        </member>
        <member name="M:Reinforced.Typings.ReferencesInspection.ReferenceProcessorBase.FilterReferences(System.Collections.Generic.IEnumerable{Reinforced.Typings.Ast.Dependency.RtReference},Reinforced.Typings.ExportedFile)">
            <summary>
            Returns refiltered and reordered reference directives that must appear in resulting file
            Return null to remain imports list untouched
            </summary>
            <param name="references">Set on initially computed references</param>
            <param name="file">File that is being exported currently</param>
            <returns>Set of refiltered/reordered references</returns>
        </member>
        <member name="T:Reinforced.Typings.TsExporter">
            <summary>
                Facade for final TypeScript export. This class supplies assemblies names or assemblies itself as parameter and
                exports resulting TypeScript file to file or to string
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TsExporter.Context">
            <summary>
            Obtains export context
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.#ctor(Reinforced.Typings.ExportContext)">
            <summary>
                Constructs new instance of TypeScript exporter
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.Initialize">
            <summary>
            Initializes TS exporter. Reads all types configuration, applies fluent configuration, resolves references
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.ExportTypes(System.String)">
            <summary>
                Exports TypeScript source to specified TextWriter according to settings
            </summary>
            <param name="fileName">File name to export files to</param>
        </member>
        <member name="M:Reinforced.Typings.TsExporter.Export">
            <summary>
                Exports TypeScript source according to settings
            </summary>
        </member>
        <member name="T:Reinforced.Typings.TypeBlueprint">
            <summary>
            Holds all information that is necessary to export particular type
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.#ctor(System.Type)">
            <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.IsExportedExplicitly">
            <summary>
            Gets whether specified type is exported explicitly
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.PathToFile">
            <summary>
            Path to file that blueprinted type will be exported to
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.Type">
            <summary>
                Type is being exported
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.TypeAttribute">
            <summary>
            Attribute for exporting class
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.ThirdParty">
            <summary>
            Gets whether type is used as third-party type only without export being performed
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.Ignored">
            <summary>
            Set of ignored members
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.Substitutions">
            <summary>
            Substitutions
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.GenericSubstitutions">
            <summary>
            Generic substitutions
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.References">
            <summary>
            References
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.Imports">
            <summary>
            Imports
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.Decorators">
            <summary>
            Decorators
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.DecoratorsForMembers">
            <summary>
            Decorators for type members
            </summary>
        </member>
        <member name="P:Reinforced.Typings.TypeBlueprint.DecoratorsForParameters">
            <summary>
            Decorators for parameters
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for type member
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for type member
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for method
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember(System.Reflection.ParameterInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for method parameter
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for property
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for field
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForMember(System.Reflection.ConstructorInfo)">
            <summary>
            Retrieves configuration attribute for constructor
            </summary>
            <param name="member">Type member</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ForEnumValue(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Retrieves configuration attribute for enum value
            </summary>
            <param name="member">Type member</param>
            <param name="create">When true, attribute will be created if not exists</param>
            <returns>Configuration attribute</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetExportedFields">
            <summary>
            Retrieves type's exported fields
            </summary>
            <returns>Array of exported fields</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetExportedProperties">
            <summary>
            Retrieves type's exported properties
            </summary>
            <returns>Array of exported properties</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetExportedMethods">
            <summary>
            Retrieves type's exported methods
            </summary>
            <returns>Array of exported methods</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored">
            <summary>
            Checks whether type is ignored during export
            </summary>
            <returns>True, when type is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored(System.Reflection.ConstructorInfo)">
            <summary>
            Checks whether constructor is ignored during export
            </summary>
            <returns>True, when constructor is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored(System.Reflection.FieldInfo)">
            <summary>
            Checks whether field is ignored during export
            </summary>
            <returns>True, when field is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored(System.Reflection.PropertyInfo)">
            <summary>
            Checks whether property is ignored during export
            </summary>
            <returns>True, when property is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored(System.Reflection.ParameterInfo)">
            <summary>
            Checks whether parameter is ignored during export
            </summary>
            <returns>True, when parameter is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored(System.Reflection.MemberInfo)">
            <summary>
            Checks whether type member is ignored during export
            </summary>
            <returns>True, when type member is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsIgnored(System.Reflection.MethodInfo)">
            <summary>
            Checks whether method is ignored during export
            </summary>
            <returns>True, when method is ignored. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetDecorators">
            <summary>
            Retrieves decorators for type
            </summary>
            <returns>Set of type's decorators</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.DecoratorsFor(System.Reflection.ParameterInfo)">
            <summary>
            Retrieves set of decorators for method parameter
            </summary>
            <param name="t">Method's parameter</param>
            <returns>Set of decorators</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.DecoratorsFor(System.Reflection.MemberInfo)">
            <summary>
            Retrieves set of decorators for type's member
            </summary>
            <param name="t">Member's parameter</param>
            <returns>Set of decorators</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.Attr``1">
            <summary>
            Retrieves type's configuration attribute
            </summary>
            <typeparam name="T">Attribute type. Subclass of <see cref="T:Reinforced.Typings.Attributes.TsDeclarationAttributeBase"/></typeparam>
            <returns>Configuration attribute. May be null</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.CamelCaseFromAttribute(System.Reflection.MemberInfo,System.String)">
            <summary>
                Conditionally (based on attribute setting) turns member name to camelCase
            </summary>
            <param name="member">Member</param>
            <param name="regularName">Regular property name</param>
            <returns>Property name in camelCase if camelCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.PascalCaseFromAttribute(System.Reflection.MemberInfo,System.String)">
            <summary>
                Conditionally (based on attribute setting) turns member name to PascalCase
            </summary>
            <param name="member">Member</param>
            <param name="regularName">Regular property name</param>
            <returns>Property name in PascalCase if pascalCasing enabled, initial string otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.ConvertToCamelCase(System.String)">
            <summary>
            Converts string to camelCase
            </summary>
            <param name="s">Source string in any case</param>
            <returns>Resulting string in camelCase</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetOrder(System.Reflection.MemberInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetOrder(System.Reflection.MethodInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetOrder(System.Reflection.PropertyInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetOrder(System.Reflection.FieldInfo)">
            <summary>
                Retrieves member order
            </summary>
            <param name="element">Method info</param>
            <returns>Method order</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetOrder">
            <summary>
                Retrieves type order to appear in results file
            </summary>
            <returns>Type name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetName(System.Reflection.ParameterInfo)">
            <summary>
                Retrieves parameter name from corresponding attribute. If attribute not present then takes parameter name via
                reflection
            </summary>
            <param name="element">Parameter info</param>
            <returns>Parameter name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetName(Reinforced.Typings.Ast.TypeNames.RtTypeName[])">
            <summary>
                Retrieves type name from type itself or from corresponding Reinforced.Typings attribute
            </summary>
            <param name="genericArguments">Generic arguments to be substituted to type</param>
            <returns>Type name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsFlatten">
            <summary>
            Gets whether type configuration required flattering inheritance hierarchy
            </summary>
            <returns>True, when hierarchy must be flatten, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsExportingAsInterface">
            <summary>
                Determines should type be exported as interface or not
            </summary>
            <returns>True, if supplied type should be exported as interface. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.IsExportingAsClass">
            <summary>
                Determines should type be exported as class or not
            </summary>
            <returns>True, if supplied type should be exported as interface. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.GetNamespace(System.Boolean)">
            <summary>
                Retrieves type namespace from type itself or from corresponding Typings attribute
            </summary>
            <param name="distinguishAutoTypes">
                Forces GetNamespace to return "-" for interfaces with IncludeInterface = false and
                null for anonymous types
            </param>
            <returns>Full-qualified namespace name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.Substitute(System.Type,Reinforced.Typings.TypeResolver)">
            <summary>
            Obtains substitution for type
            </summary>
            <param name="t">Type to find substitution for</param>
            <param name="tr">Type resolver instance</param>
            <returns>Substitution AST</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeBlueprint.CanFlatten">
            <summary>
            Gets whether type hierarchy can be flatten
            </summary>
            <returns></returns>
        </member>
        <member name="T:Reinforced.Typings.TypeExtensions">
            <summary>
                Useful extensions for reflection
            </summary>
        </member>
        <member name="F:Reinforced.Typings.TypeExtensions.MembersFlags">
            <summary>
                Binding flags for searching all members
            </summary>
        </member>
        <member name="F:Reinforced.Typings.TypeExtensions.PublicMembersFlags">
            <summary>
                Binding flags for searching all members
            </summary>
        </member>
        <member name="T:Reinforced.Typings.TypeExtensions.MethodEqComparer">
            <summary>
            Simple comparer to detect overridden methods
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsStatic(System.Type)">
            <summary>
                Determines is type is static
            </summary>
            <param name="t">Type</param>
            <returns>True if type is static. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsStatic(System.Reflection.MemberInfo)">
            <summary>
                Determines is member static or not
            </summary>
            <param name="member">Type member</param>
            <returns>True if member is static. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsStatic(System.Reflection.PropertyInfo)">
            <summary>
                Determines is property static or not
            </summary>
            <param name="propertyInfo">Property</param>
            <returns>True if member is static. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsNullable(System.Type)">
            <summary>
                Determines is type derived from Nullable or not
            </summary>
            <param name="t">Type</param>
            <returns>True if type is nullable value type. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsTuple(System.Type)">
            <summary>
            Determines if type is one of System.Tuple types set
            </summary>
            <param name="t">Type to check</param>
            <returns>True when type is tuple, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsDictionary(System.Type)">
            <summary>
                Determines if type is Dictionary-like
            </summary>
            <param name="t">Type</param>
            <returns>True if type is derived from dictionary type</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsEnumerable(System.Type)">
            <summary>
                Determines if type is enumerable regardless of generic spec
            </summary>
            <param name="t">Type</param>
            <returns>True if type is enumerable (incl. array type). False otherwise.</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsNongenericEnumerable(System.Type)">
            <summary>
                Determines if supplied type is non-generic enumerable
            </summary>
            <param name="t">Type</param>
            <returns>True if supplied type is nongeneric enumerable. False otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsDelegate(System.Type)">
            <summary>
                Determines if supplied type is delegate type
            </summary>
            <param name="t">Type</param>
            <returns>True, if supplied type is delegate, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions._IsAsyncType(System.Type)">
            <summary>
            Determines if type is one of System.Tuple types set
            </summary>
            <param name="t">Type to check</param>
            <returns>True when type is tuple, false otherwise</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.FieldInfo)">
            <summary>
                Returns access modifier for specified field
            </summary>
            <param name="fieldInfo">Field</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.MethodInfo)">
            <summary>
                Returns access modifier for specified method
            </summary>
            <param name="methodInfo">Method</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsAsync(System.Reflection.MethodInfo)">
            <summary>
                Returns access modifier for specified method
            </summary>
            <param name="methodInfo">Method</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.ConstructorInfo)">
            <summary>
                Returns access modifier for specified constructor
            </summary>
            <param name="constructorInfo">Constructor</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.PropertyInfo)">
            <summary>
                Returns access modifier for specified constructor
            </summary>
            <param name="propertyInfo">Property</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetModifier(System.Reflection.MemberInfo)">
            <summary>
                Returns access modifier for specified type member
            </summary>
            <param name="member">Type member</param>
            <returns>Access modifier string</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.ToModifierText(Reinforced.Typings.AccessModifier)">
            <summary>
                Converts AccessModifier to corresponding TypeScript source text
            </summary>
            <param name="modifier">Access modifier</param>
            <returns>Access modifier text</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.ToModifierOmitPublic(Reinforced.Typings.AccessModifier)">
            <summary>
                Converts AccessModifier to corresponding TypeScript source text
            </summary>
            <param name="modifier">Access modifier</param>
            <returns>Access modifier text</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetArg(System.Type)">
            <summary>
                Retrieves first type argument of type
            </summary>
            <param name="t">Type</param>
            <returns>First type argument</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.CleanGenericName(System.Type)">
            <summary>
                Removes generics postfix (all text after '`') from typename
            </summary>
            <param name="t">Type</param>
            <returns>Clean, genericless name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.IsBounceProperty(System.Reflection.PropertyInfo)">
            <summary>
                Determines if propercy is "bounced".
                It means property with different accesor's access level
            </summary>
            <param name="propertyInfo">Property</param>
            <returns>True if property has different access levels for accessor</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetNullableAttributeValue(System.Reflection.ParameterInfo)">
            <summary>
            Reads the new compiler specific nullable attribute of the parameter or its parent scopes.
            </summary>
            <param name="member">The parameter to check for the availability of a nullable attribute.</param>
            <returns>the value of the first attribute to find or <c>null</c> if none is available.</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeExtensions.GetNullableAttributeValue(System.Reflection.MemberInfo)">
            <summary>
            Reads the new compiler specific nullable attribute of a property or field or their parent scopes.
            </summary>
            <param name="member">The property or field to check for the availability of a nullable attribute.</param>
            <returns>the value of the first attribute to find or <c>null</c> if none is available.</returns>
        </member>
        <member name="T:Reinforced.Typings.TypeResolver">
            <summary>
                Type resolver. It is helper class to convert source types, members and parameter names to typescript ones
            </summary>
        </member>
        <member name="F:Reinforced.Typings.TypeResolver.NumericTypes">
            <summary>
            Hash set of all numeric types
            </summary>
        </member>
        <member name="F:Reinforced.Typings.TypeResolver.IntegerTypes">
            <summary>
            Hash set of all integer types
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeResolver.#ctor(Reinforced.Typings.ExportedFile)">
            <summary>
                Constructs new type resolver
            </summary>
        </member>
        <member name="M:Reinforced.Typings.TypeResolver.ResolveTypeName(System.Type)">
            <summary>
                Returns typescript-friendly type name node for specified type.
                This method successfully handles dictionaries, IEnumerables, arrays, another TsExport-ed types, void, delegates,
                most of CLR built-in types, parametrized types etc.
                It also considers Ts*-attributes while resolving type names
                If it cannot handle anything then it will return "any"
            </summary>
            <param name="t">Specified type</param>
            <returns>Typescript-friendly type name</returns>
        </member>
        <member name="M:Reinforced.Typings.TypeResolver.ResolveTypeName(System.Type,System.Boolean)">
            <summary>
                Returns typescript-friendly type name node for specified type.
                This method successfully handles dictionaries, IEnumerables, arrays, another TsExport-ed types, void, delegates,
                most of CLR built-in types, parametrized types etc.
                It also considers Ts*-attributes while resolving type names
                If it cannot handle anything then it will return "any"
            </summary>
            <param name="t">Specified type</param>
            <param name="usePromiseType">if true, then async types like "Task" are supported and translated to "Promise".
            Otherwise the generics value of "Task" is used or "void".</param>
            <returns>Typescript-friendly type name</returns>
        </member>
        <member name="P:Reinforced.Typings.Visitors.TextExportingVisitor.ExportContext">
            <summary>
            Gets current export context
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Visitors.TypeScript.TypeScriptExportVisitor">
            <summary>
            Visitor that generates TypeScript code (.ts) from existing model
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Visitors.TypeScript.TypeScriptExportVisitor.Modifiers(Reinforced.Typings.Ast.RtMember)">
            <summary>
            Writes modifiers for type member
            </summary>
            <param name="member">Type member</param>
        </member>
        <member name="M:Reinforced.Typings.Visitors.TypeScript.TypeScriptExportVisitor.EmptyBody(Reinforced.Typings.Ast.TypeNames.RtTypeName,System.Boolean)">
            <summary>
            Writes empty method body of known return type
            </summary>
            <param name="returnType">Method return type</param>
            <param name="isAsyncMethod">Whether the method is tagged as "async", then no Promise need to be created
            directly. TypeScript compiler does it for us.</param>
        </member>
        <member name="M:Reinforced.Typings.Visitors.TypeScript.TypeScriptExportVisitor.CodeBlock(System.String)">
            <summary>
            Writes code block with correct tabulation
            </summary>
            <param name="content">Code content</param>
        </member>
        <member name="M:Reinforced.Typings.Visitors.TypeScript.TypeScriptExportVisitor.CodeBlock(Reinforced.Typings.Ast.RtRaw)">
            <summary>
            Writes AST node as code block with correct tabulation
            </summary>
            <param name="content">Code content</param>
        </member>
        <member name="M:Reinforced.Typings.Visitors.TypeScript.TypeScriptExportVisitor.SequentialVisit``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Performs sequential visiting of AST nodes inserting separator in between
            </summary>
            <typeparam name="T"></typeparam>
            <param name="nodes">Nodes to visit</param>
            <param name="separator">Seperator string</param>
        </member>
        <member name="T:Reinforced.Typings.Visitors.Typings.TypingsExportVisitor">
            <summary>
            Visitor that is generating .d.ts from existing model
            </summary>
        </member>
        <member name="T:Reinforced.Typings.Xmldoc.DocumentationManager">
            <summary>
                XMLDOC documentation manager
            </summary>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Reflection.MemberInfo)">
            <summary>
                Returns documentation member for class member
            </summary>
            <param name="member">Class member</param>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Reflection.MethodInfo)">
            <summary>
            Returns documentation member for method
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Reflection.ConstructorInfo)">
            <summary>
                Returns documentation for constructor
            </summary>
            <param name="constructor">Constructor</param>
        </member>
        <member name="M:Reinforced.Typings.Xmldoc.DocumentationManager.GetDocumentationMember(System.Type)">
            <summary>
                Returns documentation for type
            </summary>
            <param name="type">Type</param>
        </member>
        <member name="P:Reinforced.Typings.Xmldoc.Model.DocumentationInheritDoc.Cref">
            <summary>
            TODO: Find a type by this cref and get its documentation?
            </summary>
        </member>
    </members>
</doc>
